<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
	<title>CLUCalc: CLUCalc - A Visual Calculator</title>
	<link href="doxygen.css" rel="stylesheet" type="text/css">
	<link href="favicon.ico" rel="SHORTCUT ICON">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1><a class="anchor" name="page_WorkWithTensors">Working with Tensors</a></h1><ul>
<li>
<a class="el" href="page_WorkWithTensors.html#sec_TensorBasics">The Basics</a> </li>
<li>
<a class="el" href="page_WorkWithTensors.html#sec_TensorLoops">Implicit Loops</a> </li>
<li>
<a class="el" href="page_WorkWithTensors.html#sec_TensorGA">Representing GA Operations</a> </li>
</ul>
<p>
<hr>
 <h2><a class="anchor" name="sec_TensorBasics">
The Basics</a></h2>
<ul>
<li>
<a class="el" href="page_WorkWithTensors.html#subsec_Tensor_Def">Defining Tensors</a> </li>
<li>
<a class="el" href="page_WorkWithTensors.html#subsec_Tensor_Access">Accessing Components</a> </li>
<li>
<a class="el" href="page_WorkWithTensors.html#subsec_Tensor_Operations">Basic Operations</a> </li>
</ul>
<p>
The variable type <code>tensor</code> is introduced with CLUScript v2.2 and implemented in CLUCalc v4.2. In the long run this tensor type will probably replace the matrix type since it is much more general and more convenient to work with. For the moment, both types exist in parallel, though.<p>
In the following I mean by the <b>valence</b> of a tensor, its number of indices. This is often also refered to as the <b>rank</b> of a tensor. However, I would like to reserve to term rank for the meaning it has for matrices.<p>
A tensor variable is basically a multi-dimensional array of scalar values. The nice feature of working with tensor variables is that implicit summations over indices can be expressed rather succinctly, as will be shown in section <a class="el" href="page_WorkWithTensors.html#sec_TensorLoops">Implicit Loops</a>.<h3><a class="anchor" name="subsec_Tensor_Def">
Defining Tensors</a></h3>
A tensor of valence three with dimensions 2, 3 and 4 is created in the following way.<p>
<div class="fragment"><pre class="fragment">    ?T = <a class="code" href="group__grp__Tensor.html#ga3">Tensor</a>(3, [2,3,4]);
</pre></div><p>
This generates the following output<p>
<b>T</b> <em>(2x3x4)</em> =<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr>
<td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr>
<td>0</td><td>0</td><td>0</td><td>0</td></tr>
</table>
<p>
<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr>
<td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr>
<td>0</td><td>0</td><td>0</td><td>0</td></tr>
</table>
<br>
<p>
It is also possible to create a tensor directly from a list or from a matrix.<p>
<div class="fragment"><pre class="fragment">?T1 = <a class="code" href="group__grp__Tensor.html#ga3">Tensor</a>([[[1,2,3],[2,3,4]], [[4,5,6], [5,6,7]]]);
?T2 = <a class="code" href="group__grp__Tensor.html#ga3">Tensor</a>(<a class="code" href="group__grp__Matrix.html#ga19">Matrix</a>(2,3));
</pre></div><p>
This generates the output<p>
<b>T1</b> <em>(2x2x3)</em> =<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>1</td><td>2</td><td>3</td></tr>
<tr>
<td>2</td><td>3</td><td>4</td></tr>
</table>
<p>
<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>4</td><td>5</td><td>6</td></tr>
<tr>
<td>5</td><td>6</td><td>7</td></tr>
</table>
<br>
<p>
<b>T2</b> <em>(2x3)</em> =<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>0</td><td>0</td><td>0</td></tr>
<tr>
<td>0</td><td>0</td><td>0</td></tr>
</table>
<br>
<h3><a class="anchor" name="subsec_Tensor_Access">
Accessing Components</a></h3>
The components of a tensor can be accessed by using round brackets, just as for matrices. For example,<p>
<div class="fragment"><pre class="fragment">T = <a class="code" href="group__grp__Tensor.html#ga3">Tensor</a>([[[1,2,3],[2,3,4]], [[4,5,6], [5,6,7]]]);
?T(2,1,3);
T(1,1,1) = 10;
?T;
</pre></div><p>
has the output<p>
<b>Constant</b> = 6 <br>
<p>
<b>T</b> <em>(2x2x3)</em> =<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>10</td><td>2</td><td>3</td></tr>
<tr>
<td>2</td><td>3</td><td>4</td></tr>
</table>
<p>
<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>4</td><td>5</td><td>6</td></tr>
<tr>
<td>5</td><td>6</td><td>7</td></tr>
</table>
<br>
<h3><a class="anchor" name="subsec_Tensor_Operations">
Basic Operations</a></h3>
The operators <code>+</code>, <code>-</code>, <code>*</code> and <code>/</code> are defined between tensor variables and scalars. Operations between tensors are explained in <a class="el" href="page_WorkWithTensors.html#sec_TensorLoops">Implicit Loops</a>. For example,<p>
<div class="fragment"><pre class="fragment">    ?T = <a class="code" href="group__grp__Tensor.html#ga3">Tensor</a>([[1,2,3],[4,5,6]]);
    ?<span class="stringliteral">"T + 1 = "</span> + (T + 1);
    ?<span class="stringliteral">"1 - T = "</span> + (1 - T);
    ?<span class="stringliteral">"T * 2 = "</span> + (T * 2);
    ?<span class="stringliteral">"T / 2 = "</span> + (T / 2);
    ?<span class="stringliteral">"2 / T = "</span> + (2 / T);
</pre></div><p>
The output is<p>
<b>T</b> <em>(2x3)</em>=<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>1</td><td>2</td><td>3</td></tr>
<tr>
<td>4</td><td>5</td><td>6</td></tr>
</table>
<br>
T + 1 =<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>2</td><td>3</td><td>4</td></tr>
<tr>
<td>5</td><td>6</td><td>7</td></tr>
</table>
<br>
1 - T =<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>0</td><td>-1</td><td>-2</td></tr>
<tr>
<td>-3</td><td>-4</td><td>-5</td></tr>
</table>
<br>
T * 2 =<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>2</td><td>4</td><td>6</td></tr>
<tr>
<td>8</td><td>10</td><td>12</td></tr>
</table>
<br>
T / 2 =<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>0.5</td><td>1</td><td>1.5</td></tr>
<tr>
<td>2</td><td>2.5</td><td>3</td></tr>
</table>
<br>
2 / T =<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>2</td><td>1</td><td>0.667</td></tr>
<tr>
<td>0.5</td><td>0.4</td><td>0.333</td></tr>
</table>
<br>
<p>
<hr>
 <h2><a class="anchor" name="sec_TensorLoops">
Implicit Loops</a></h2>
<ul>
<li>
<a class="el" href="page_WorkWithTensors.html#subsec_Tensor_Print">Printing Tensor Components</a> </li>
<li>
<a class="el" href="page_WorkWithTensors.html#subsec_Tensor_Assign">Assigning Tensor Values</a> </li>
<li>
<a class="el" href="page_WorkWithTensors.html#subsec_Tensor_Contract">Tensor Contraction</a> </li>
<li>
<a class="el" href="page_WorkWithTensors.html#subsec_Tensor_PointIndices">Point Indices</a> </li>
<li>
<a class="el" href="page_WorkWithTensors.html#subsec_Tensor_IndexRange">Restricting Index Ranges</a> </li>
<li>
<a class="el" href="page_WorkWithTensors.html#subsec_Tensor_AddSub">Addition and Subtraction</a> </li>
</ul>
<p>
In order to make full use of tensor variables, you need to know about the generation of implicit loops by using counting indices. There are two different types of counting indices: contraction- and point-indices. Contraction-indices are negative integer values, while point-indices are values between -1 and 0. Contraction indices have the effect of generating a summation loop over the range of the respective index as is explained in <a class="el" href="page_WorkWithTensors.html#subsec_Tensor_Contract">Tensor Contraction</a>. Point-indices on the other hand, imply a loop over all values of an index, but there is no implicit summation. This is explained in more detail in <a class="el" href="page_WorkWithTensors.html#subsec_Tensor_PointIndices">Point Indices</a>.<h3><a class="anchor" name="subsec_Tensor_Print">
Printing Tensor Components</a></h3>
All components of a tensor are printed to the output window by using the standard <code></code>? operator, as shown before. However, it is also possible to only print a subset of elements by using a counting index. Consider the following example.<p>
<div class="fragment"><pre class="fragment">    ?T = <a class="code" href="group__grp__Tensor.html#ga3">Tensor</a>([[1,2,3],[4,5,6]]);
    ?T(1, -1);
    ?T(-1, 1);
</pre></div><p>
The output is<p>
<b>T</b> <em>(2x3)</em>=<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>1</td><td>2</td><td>3</td></tr>
<tr>
<td>4</td><td>5</td><td>6</td></tr>
</table>
<br>
<b>Constant</b> <em>(3)</em>=<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>1</td><td>2</td><td>3</td></tr>
</table>
<br>
<b>Constant</b> <em>(2)</em>=<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>1</td><td>4</td></tr>
</table>
<br>
<p>
That is, the expression <code>?T(1, -1)</code> prints the values of <code>T</code> in the first row, while <code>?T(-1, 1)</code> prints the first column. Basically, the idea of counting indices is that when an operation is applied to an expression like <code>T(-1, 1)</code>, then it is applied to the set of elements that are contained in <code>T</code> when counting through all allowed values of the first index.<h3><a class="anchor" name="subsec_Tensor_Assign">
Assigning Tensor Values</a></h3>
It is also possible to assign values only to a particular part of a tensor. For example,<p>
<div class="fragment"><pre class="fragment">    A = <a class="code" href="group__grp__Tensor.html#ga3">Tensor</a>(2, [2,3]);
    A(1, -1) = 2;
    ?A;
</pre></div><p>
gives<p>
<b>A</b> <em>(2x3)</em> =<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>2</td><td>2</td><td>2</td></tr>
<tr>
<td>0</td><td>0</td><td>0</td></tr>
</table>
<br>
<p>
That is, all elements in the first row of A are set to the value 2. Only setting the diagonal values can be done in the following way<p>
<div class="fragment"><pre class="fragment">    A = <a class="code" href="group__grp__Tensor.html#ga3">Tensor</a>(2, [2,3]);
    A(-1, -1) = 2;
    ?A;
</pre></div><p>
which gives<p>
<b>A</b> <em>(2x3)</em> =<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>2</td><td>0</td><td>0</td></tr>
<tr>
<td>0</td><td>2</td><td>0</td></tr>
</table>
<br>
<p>
One can also assign parts of one tensor to parts of another tensor.<p>
<div class="fragment"><pre class="fragment">    A = <a class="code" href="group__grp__Tensor.html#ga3">Tensor</a>([[1,2], [3,4]]);
    B = <a class="code" href="group__grp__Tensor.html#ga3">Tensor</a>([[2,3], [1,4]]);

    A(-1,1) = B(2,-1);
    ?A;
    
    ?C = A(1,-1);
</pre></div><p>
This generates the following output.<p>
<b>A</b> <em>(2x2)</em> =<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>1</td><td>2</td></tr>
<tr>
<td>4</td><td>4</td></tr>
</table>
<p>
<br>
<b>C</b> <em>(2)</em> =<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>1</td><td>2</td></tr>
</table>
<br>
<h3><a class="anchor" name="subsec_Tensor_Contract">
Tensor Contraction</a></h3>
The following example evaluates the standard matrix product between two 2-valence tensors (i.e. matrices). The equivalent mathematical expressions are<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ A = \left(\begin{array}{cc} 1 &amp; 2 \\ 3 &amp; 4 \end{array}\right), \quad B = \left(\begin{array}{cc} 2 &amp; 3 \\ 1 &amp; 4 \end{array}\right), \quad C_{i,k} = \sum_{j=1}^2\;A_{i,j}\,B_{j,k}. \]" src="form_192.png">
<p>
<p>
<div class="fragment"><pre class="fragment">    ?A = <a class="code" href="group__grp__Tensor.html#ga3">Tensor</a>([[1,2], [3,4]]);
    ?B = <a class="code" href="group__grp__Tensor.html#ga3">Tensor</a>([[2,3], [1,4]]);

    ?C = A(-1,-2) * B(-2, -3);
</pre></div><p>
This results in<p>
<b>A</b> <em>(2x2)</em> =<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>1</td><td>2</td></tr>
<tr>
<td>3</td><td>4</td></tr>
</table>
<br>
<b>B</b> <em>(2x2)</em> =<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>2</td><td>3</td></tr>
<tr>
<td>1</td><td>4</td></tr>
</table>
<br>
<b>C</b> <em>(2x2)</em> =<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>4</td><td>11</td></tr>
<tr>
<td>10</td><td>25</td></tr>
</table>
<br>
<p>
Hence, there is an implicit summation over the index values at the positions where a repeated negative appears. It may also help to define some integer variables to simplify the CLUScript expression. For example,<p>
<div class="fragment"><pre class="fragment">    i = -1; j = -2; k = -3;
    
    A = <a class="code" href="group__grp__Tensor.html#ga3">Tensor</a>([[1,2], [3,4]]);
    B = <a class="code" href="group__grp__Tensor.html#ga3">Tensor</a>([[2,3], [1,4]]);

    C = A(i, j) * B(j, k);
</pre></div><p>
This has the same effect as the previous example, since there will be a contraction over the index <code>j</code>. Note that the order of the elements in C is according to the values of the counting indices. That is, in the above example -1 is the first dimension of C and -3 the second dimension. Hence, <code>D = A(k, j) * B(j, i)</code> generates a tensor that is transposed with respect to tensor C.<p>
Note that instead of contracting with a product, this can also be done with division. For example, the equivalent to the mathematical expressions <p class="formulaDsp">
<img class="formulaDsp" alt="\[ A = \left(\begin{array}{cc} 1 &amp; 2 \\ 3 &amp; 4 \end{array}\right), \quad B = \left(\begin{array}{cc} 2 &amp; 3 \\ 1 &amp; 4 \end{array}\right), \quad C_{i,k} = \sum_{j=1}^2\;\frac{A_{i,j}}{B_{j,k}}, \]" src="form_193.png">
<p>
 is the following CLUScript.<p>
<div class="fragment"><pre class="fragment">    ?A = <a class="code" href="group__grp__Tensor.html#ga3">Tensor</a>([[1,2], [3,4]]);
    ?B = <a class="code" href="group__grp__Tensor.html#ga3">Tensor</a>([[2,3], [1,4]]);

    ?C = A(-1,-2) / B(-2, -3);
</pre></div><p>
The output is<p>
<b>A</b> <em>(2x2)</em>=<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>1</td><td>2</td></tr>
<tr>
<td>3</td><td>4</td></tr>
</table>
<br>
<b>B</b> <em>(2x2)</em>=<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>2</td><td>3</td></tr>
<tr>
<td>1</td><td>4</td></tr>
</table>
<br>
<b>C</b> <em>(2x2)</em>=<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>2.5</td><td>0.833</td></tr>
<tr>
<td>5.5</td><td>2</td></tr>
</table>
<br>
<h3><a class="anchor" name="subsec_Tensor_PointIndices">
Point Indices</a></h3>
Point-indices denote indices over which implicit loops are to be executed, however without summation over the index range. For example, suppose you have two tensors of the same size and you would simply like to multiply the corresponding values. Mathematically this may be expressed as<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ A = \left(\begin{array}{cc} 1 &amp; 2 \\ 3 &amp; 4 \end{array}\right), \quad B = \left(\begin{array}{cc} 2 &amp; 3 \\ 1 &amp; 4 \end{array}\right), \quad C_{i,j} = \;A_{i,j}\,B_{i,j}. \]" src="form_194.png">
<p>
<p>
The corresponding CLUScript looks like this<p>
<div class="fragment"><pre class="fragment">?A = <a class="code" href="group__grp__Tensor.html#ga3">Tensor</a>([[1,2], [3,4]]);
?B = <a class="code" href="group__grp__Tensor.html#ga3">Tensor</a>([[2,3], [1,4]]);

?C = A(-.1,-.2) * B(-.1, -.2);
</pre></div><p>
which generates the output<p>
<b>A</b> <em>(2x2)</em> =<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>1</td><td>2</td></tr>
<tr>
<td>3</td><td>4</td></tr>
</table>
<br>
<p>
<b>B</b> <em>(2x2)</em> =<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>2</td><td>3</td></tr>
<tr>
<td>1</td><td>4</td></tr>
</table>
<br>
<p>
<b>C</b> <em>(2x2)</em> =<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>2</td><td>6</td></tr>
<tr>
<td>3</td><td>16</td></tr>
</table>
<br>
<p>
It is also possible to mix contraction- and point-indices. For example, suppose you would like to evaluate the scalar product between corresponding column vectors in two tensors. Mathematically this can be written as<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ A = \left(\begin{array}{cc} 1 &amp; 2 \\ 3 &amp; 4 \end{array}\right), \quad B = \left(\begin{array}{cc} 2 &amp; 3 \\ 1 &amp; 4 \end{array}\right), \quad C_{j} = \sum_{i=1}^2 \;A_{i,j}\,B_{i,j}. \]" src="form_195.png">
<p>
<p>
The corresponding CLUScript looks like this.<p>
<div class="fragment"><pre class="fragment">?A = <a class="code" href="group__grp__Tensor.html#ga3">Tensor</a>([[1,2], [3,4]]);
?B = <a class="code" href="group__grp__Tensor.html#ga3">Tensor</a>([[2,3], [1,4]]);

?C = A(-1,-.2) * B(-1, -.2);
</pre></div><p>
which generates the output<p>
<b>A</b> <em>(2x2)</em> =<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>1</td><td>2</td></tr>
<tr>
<td>3</td><td>4</td></tr>
</table>
<br>
<p>
<b>B</b> <em>(2x2)</em> =<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>2</td><td>3</td></tr>
<tr>
<td>1</td><td>4</td></tr>
</table>
<br>
<p>
<b>C</b> <em>(2)</em> =<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>5</td><td>22</td></tr>
</table>
<br>
<h3><a class="anchor" name="subsec_Tensor_IndexRange">
Restricting Index Ranges</a></h3>
So far all counting indices were always evaluated over their whole allowed range. However, quite often it is desirable to restrain a counting index to a subset of index values. In CLUScript this can be done in two different ways, by either giving a range or a list of index values.<p>
<div class="fragment"><pre class="fragment">    ?A = <a class="code" href="group__grp__Tensor.html#ga3">Tensor</a>([[1,2,3,4], [5,6,7,8]]);

    ?A(-1, [-2,1,3]); <span class="comment">// Range for -2</span>
    ?A(-1, [-2, [1,3,4]]); <span class="comment">// Index List</span>
</pre></div><p>
This generates the output<p>
<b>A</b> <em>(2x4)</em> =<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>1</td><td>2</td><td>3</td><td>4</td></tr>
<tr>
<td>5</td><td>6</td><td>7</td><td>8</td></tr>
</table>
<br>
<p>
<b>Constant</b> <em>(2x3)</em> =<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>1</td><td>2</td><td>3</td></tr>
<tr>
<td>5</td><td>6</td><td>7</td></tr>
</table>
<br>
<p>
<b>Constant</b> <em>(2x3)</em> =<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>1</td><td>3</td><td>4</td></tr>
<tr>
<td>5</td><td>7</td><td>8</td></tr>
</table>
<br>
<h3><a class="anchor" name="subsec_Tensor_AddSub">
Addition and Subtraction</a></h3>
Implicit loops can also be perfomed when adding and subtracting tensors, as well as adding or subtracting constants to/from tensors. Here is an example,<p>
<div class="fragment"><pre class="fragment">    ?T = <a class="code" href="group__grp__Tensor.html#ga3">Tensor</a>([[2,0,0], [0,1,0]]);
    ?S1 = T - 1;
    ?S2 = 1 - T;
</pre></div><p>
which generates the output<p>
<b>T</b> <em>(2x3)</em>=<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>2</td><td>0</td><td>0</td></tr>
<tr>
<td>0</td><td>1</td><td>0</td></tr>
</table>
<br>
<b>S1</b> <em>(2x3)</em>=<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>1</td><td>-1</td><td>-1</td></tr>
<tr>
<td>-1</td><td>0</td><td>-1</td></tr>
</table>
<br>
<b>S2</b> <em>(2x3)</em>=<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>-1</td><td>1</td><td>1</td></tr>
<tr>
<td>1</td><td>0</td><td>1</td></tr>
</table>
<br>
<p>
That is, subtracting a constant from a tensor, subtracts it from each component of the tensor. This, of course, also works when using counting indices. Here is an example where a tensor is subtracted from its transpose.<p>
<div class="fragment"><pre class="fragment">    ?T = <a class="code" href="group__grp__Tensor.html#ga3">Tensor</a>([[1,2], [3,4]]);
    ?S = T(-2,-1) - T(-1,-2);
</pre></div><p>
The output is<p>
<b>T</b> <em>(2x2)</em>=<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>1</td><td>2</td></tr>
<tr>
<td>3</td><td>4</td></tr>
</table>
<br>
<b>S</b> <em>(2x2)</em>=<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>0</td><td>1</td></tr>
<tr>
<td>-1</td><td>0</td></tr>
</table>
<br>
<p>
<hr>
 <h2><a class="anchor" name="sec_TensorGA">
Representing GA Operations</a></h2>
The inner, outer and geometric product can all be represented as bilinear functions, while operations like the reverse or dual can be represented as linear functions. In section <a class="el" href="page_SolveMVEqns.html#sec_SolveMV_Intro">Introduction</a> it is shown why this is case. The basic idea is to write the components of multivectors as vectors. A product of two multivectors can then be written as the contraction of their vector representations with a tensor. For example, let the components of multivector A and B be given by <img class="formulaInl" alt="$\alpha^i$" src="form_196.png"> and <img class="formulaInl" alt="$\beta^i$" src="form_197.png"> , respectively. Then the geometric product of A and B can be written as <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \gamma^k = \sum_i\,\sum_j\;\alpha^i\,\beta^j\;{g^k}_{ij}, \]" src="form_198.png">
<p>
 where the <img class="formulaInl" alt="$\gamma^k$" src="form_199.png"> denote the components of the resultant multivector, and <img class="formulaInl" alt="${g^k}_{ij}$" src="form_102.png"> denotes the components of the tensor encoding the geometric product. This translation of geometric algebra operations into tensor contractions allows the application of linear algebra solution methods to geometric algebra.<p>
Note that equations of the above type could also be evaluated in CLUScript before by using the function <a class="el" href="group__grp__Matrix.html#ga13">GetMVProductMatrix()</a>. However, using this function the product tensor <img class="formulaInl" alt="${g^k}_{ij}$" src="form_102.png"> could not be obtained by itself, but only its contraction with a vector, which results in a matrix. If we want to treat more complex equation using tensor, we need to be able to deal with the product tensors themselves.<p>
The above calculation can be performed in CLUScript using tensors in the following way.<p>
<div class="fragment"><pre class="fragment">    vA = <a class="code" href="group__grp__GAFunc.html#ga36">VecE3</a>(1,2,0);
    vB = <a class="code" href="group__grp__GAFunc.html#ga36">VecE3</a>(2,0,3);

    <span class="comment">// Transformation of multivector into tensor</span>
    tA = <a class="code" href="group__grp__Tensor.html#ga1">MV2Tensor</a>(vA); <span class="comment">// Column vector</span>
    tB = <a class="code" href="group__grp__Tensor.html#ga1">MV2Tensor</a>(vB); <span class="comment">// Column vector</span>
    
    <span class="comment">// Print first column as row</span>
    ?tA(-1,1);
    ?tB(-1,1);
    
    <span class="comment">// Generate geometric product tensor for</span>
    <span class="comment">// 3D-Euclidean space</span>
    tG = <a class="code" href="group__grp__Tensor.html#ga0">GAOpTensor</a>(<a class="code" href="group__grp__AlgIDs.html#ga1">GA_E3</a>, <a class="code" href="group__grp__OpIDs.html#ga1">MVOP_GEO</a>);
    ?<span class="stringliteral">"Size of tG = "</span> + <a class="code" href="group__grp__Misc.html#ga10">Str</a>(<a class="code" href="group__grp__GAFunc.html#ga28">Size</a>(tG));
    
    <span class="comment">// Contraction of vectors with tensor</span>
    ?tC = tA(-1,1) * tB(-2,1) * tG(-3,-1,-2);
    
    <span class="comment">// Transformation of tensor into multivector</span>
    ?vC = <a class="code" href="group__grp__Tensor.html#ga6">Tensor2MV</a>(tC);
    ?vA * vB;
</pre></div><p>
This generates the output<p>
<b>Constant</b> <em>(8)</em> =<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>0</td><td>1</td><td>2</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
</table>
<br>
<p>
<b>Constant</b> <em>(8)</em> =<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>0</td><td>2</td><td>0</td><td>3</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
</table>
<br>
<p>
Size of tG = <b>[</b> 8 <b>,</b> 8 <b>,</b> 8 <b>]</b><br>
<b>tC</b> <em>(8)</em> = <table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>2</td><td>0</td><td>0</td><td>0</td><td>6</td><td>-3</td><td>-4</td><td>0</td></tr>
</table>
<br>
<p>
<b>vC</b> <em>(1)</em> = <br>
<b>[</b> 2 + 6 <b>e23</b> + -3 <b>e31</b> + -4 <b>e12</b> <b>]</b><p>
<br>
<p>
<b>Constant</b> = 2 + 6 <b>e23</b> + -3 <b>e31</b> + -4 <b>e12</b><br>
<p>
The variables tA and tB are tensors of dimensions 8x1, i.e. they are column vectors. The tensor tG has dimension 8x8x8. The contraction of the vectors with the tensor is equivalent to the geometric product of the corresponding multivectors. It is also possible to pass a list of vectors to <a class="el" href="group__grp__Tensor.html#ga1">MV2Tensor()</a>, in which case a tensor is created that contains the components of the multivectors in its columns. The following script generates the same output as the previous one.<p>
<div class="fragment"><pre class="fragment"><span class="comment">// Create list of multivectors</span>
lVec = [];
lVec &lt;&lt; <a class="code" href="group__grp__GAFunc.html#ga36">VecE3</a>(1,2,0);
lVec &lt;&lt; <a class="code" href="group__grp__GAFunc.html#ga36">VecE3</a>(2,0,3);

<span class="comment">// Transformation of multivectors into tensor.</span>
<span class="comment">// The multivectors form the columns of the tensor.</span>
tVec = <a class="code" href="group__grp__Tensor.html#ga1">MV2Tensor</a>(lVec); 

<span class="comment">// Print columns separately as rows</span>
?tVec(-1,1);
?tVec(-1,2);

<span class="comment">// Generate geometric product tensor for</span>
<span class="comment">// 3D-Euclidean space</span>
tG = <a class="code" href="group__grp__Tensor.html#ga0">GAOpTensor</a>(<a class="code" href="group__grp__AlgIDs.html#ga1">GA_E3</a>, <a class="code" href="group__grp__OpIDs.html#ga1">MVOP_GEO</a>);
?<span class="stringliteral">"Size of tG = "</span> + <a class="code" href="group__grp__Misc.html#ga10">Str</a>(<a class="code" href="group__grp__GAFunc.html#ga28">Size</a>(tG));

<span class="comment">// Contraction of vectors with tensor</span>
?tC = tVec(-1,1) * tVec(-2,2) * tG(-3,-1,-2);

<span class="comment">// Transformation of tensor into multivector</span>
?vC = <a class="code" href="group__grp__Tensor.html#ga6">Tensor2MV</a>(tC);
<span class="comment">// Geometric product of all vectors in list lVec.</span>
?<a class="code" href="group__grp__MathFunc.html#ga37">prod</a>(lVec);
</pre></div><h3><a class="anchor" name="subsec_Tensors_GAMask">
Masking</a></h3>
Typically only a few components of the multivetors we are working with are non-zero. In the above example, the initial multivectors are 3D-vectors, but they are still represented by 8-dimensional vectors in the tensor form. In projective and conformal space the ratio of used components to unused components is usually even much higher. In order to reduce the numerical complexity, it is therefore possible to define masks that define which components of a multivector are mapped into the tensor form. Again this is best explained with an example.<p>
<div class="fragment"><pre class="fragment">    <span class="comment">// Create list of multivectors</span>
    lVec = [];
    lVec &lt;&lt; <a class="code" href="group__grp__GAFunc.html#ga36">VecE3</a>(1,2,0);
    lVec &lt;&lt; <a class="code" href="group__grp__GAFunc.html#ga36">VecE3</a>(2,0,3);

    <span class="comment">// Mask for vectors</span>
    lVecMask = 
        [ 0, <span class="comment">// Scalar</span>
        1, 2, 3, <span class="comment">// Vector</span>
        0, 0, 0, <span class="comment">// Bivector</span>
        0 <span class="comment">// Trivector</span>
        ];
            
    <span class="comment">// Transformation of multivectors into tensor.</span>
    <span class="comment">// The multivectors form the columns of the tensor.</span>
    tVec = <a class="code" href="group__grp__Tensor.html#ga1">MV2Tensor</a>(lVec, lVecMask); 

    <span class="comment">// Print columns separately as rows</span>
    <span class="comment">// There are only three components now</span>
    ?tVec(-1,1);
    ?tVec(-1,2);

    <span class="comment">// Generate geometric product tensor for</span>
    <span class="comment">// 3D-Euclidean space using mask.</span>
    lResMask = 0;
    tG = <a class="code" href="group__grp__Tensor.html#ga0">GAOpTensor</a>(<a class="code" href="group__grp__AlgIDs.html#ga1">GA_E3</a>, <a class="code" href="group__grp__OpIDs.html#ga1">MVOP_GEO</a>, lVecMask, lVecMask, lResMask);
    ?<span class="stringliteral">"Size of tG = "</span> + <a class="code" href="group__grp__Misc.html#ga10">Str</a>(<a class="code" href="group__grp__GAFunc.html#ga28">Size</a>(tG));
    ?<span class="stringliteral">"Result Mask = "</span> + <a class="code" href="group__grp__Misc.html#ga10">Str</a>(lResMask);

    <span class="comment">// Contraction of vectors with tensor</span>
    ?tC = tVec(-1,1) * tVec(-2,2) * tG(-3,-1,-2);

    <span class="comment">// Transformation of tensor into multivector</span>
    ?vC = <a class="code" href="group__grp__Tensor.html#ga6">Tensor2MV</a>(tC, lResMask);

    <span class="comment">// Geometric product of all elements in lVec</span>
    ?<a class="code" href="group__grp__MathFunc.html#ga37">prod</a>(lVec);
</pre></div><p>
This generates the output<p>
<b>Constant</b> <em>(3)</em>=<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>1</td><td>2</td><td>0</td></tr>
</table>
<br>
<b>Constant</b> <em>(3)</em>=<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>2</td><td>0</td><td>3</td></tr>
</table>
<br>
Size of tG = <b>[</b> 4 <b>,</b> 3 <b>,</b> 3 <b>]</b><br>
Result Mask = <b>[</b> 1 <b>,</b> 0 <b>,</b> 0 <b>,</b> 0 <b>,</b> 2 <b>,</b> 3 <b>,</b> 4 <b>,</b> 0 <b>]</b><br>
<b>tC</b> <em>(4)</em>=<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>2</td><td>6</td><td>-3</td><td>-4</td></tr>
</table>
<br>
<b>vC</b> <em>(1)</em>= <br>
<b>[</b> 2 + 6 <b>e23</b> + -3 <b>e31</b> + -4 <b>e12</b> <b>]</b><p>
<br>
<b>Constant</b> = 2 + 6 <b>e23</b> + -3 <b>e31</b> + -4 <b>e12</b><br>
<p>
The variable <code>lVecMask</code> is a list with eight entries, relating to the eight dimensions of the Geometric Algebra of 3D-Euclidean space. In the above example <code>lVecMask</code> is defined such that the entries relating to the vector components are given consecutive non-zero values. The tensors generated from the multivectors by using this mask, then only contain the three vector components.<p>
The tensor representing the geometric product has to have different dimensions now as well. Therefore, the mask used to generate the tensor <code>tVec</code> has to be specified in the function <a class="el" href="group__grp__Tensor.html#ga0">GAOpTensor()</a>. This function takes as last parameter a variable that either already contains a result mask, or in which the resultant mask will be stored. In the above example <code>lResMask</code> is set to zero, which tells the function <a class="el" href="group__grp__Tensor.html#ga0">GAOpTensor()</a> that it should set this variable to the resultant mask. The resultant mask depends on the two other masks given. It basically describes, which components in a multivector can at most be non-zero under the given operation. In the above example the two mask <code>lVecMask</code> specifies that the left and right operands of the geometric products will be vectors. It then follows that the result of the geometric product will generate a multivector that has at most a scalar and three bivector components. Hence, the result mask in <code>lResMask</code>.<p>
The geometric product is then executed by contraction of the two vectors in <code>tVec</code> with the geometric product tensor <code>tG</code>. Note that <code>tG</code> is now of dimensions 4x3x3. In order to transform the resultant tensor <code>tC</code> back into a multivector the resultant mask <code>lResMask</code> has to be given in the function <a class="el" href="group__grp__Tensor.html#ga6">Tensor2MV()</a>.<p>
If we were only interested in a particular subset of components of the resultant multivector, we could have also specified <code>lResMask</code> accordingly before a call to <a class="el" href="group__grp__Tensor.html#ga0">GAOpTensor()</a>. </body></html>
