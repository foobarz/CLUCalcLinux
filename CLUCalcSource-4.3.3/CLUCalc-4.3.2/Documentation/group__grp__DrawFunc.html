<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
	<title>CLUCalc: CLUCalc - A Visual Calculator</title>
	<link href="doxygen.css" rel="stylesheet" type="text/css">
	<link href="favicon.ico" rel="SHORTCUT ICON">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>Drawing Functions<br>
<small>
[<a class="el" href="group__grp__Functions.html">Functions</a>]</small>
</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga0">AddFrameOrigin</a> (scalar x, scalar y, scalar z)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a vector to the current origin of the drawing frame.  <a href="#ga0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga1">AddFrameRotor</a> (multivector R)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a rotation to the drawing frame.  <a href="#ga1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">color&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga3">Color</a> (scalar r, scalar g, scalar b, scalar a)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a color variable.  <a href="#ga3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">color&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga2">Color</a> (scalar r, scalar g, scalar b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a color variable.  <a href="#ga2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga4">DrawArc</a> (multivector P, multivector A, multivector B, scalar Rad, counter Short)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draws an arc.  <a href="#ga4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga6">DrawArrow</a> (scalar ax, scalar ay, scalar az, scalar bx, scalar by, scalar bz)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draws an arrow.  <a href="#ga6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga5">DrawArrow</a> (multivector A, multivector B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draws an arrow.  <a href="#ga5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga8">DrawBox</a> (multivector P, multivector A, multivector B, scalar Depth, list CornerColorList)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draws a box.  <a href="#ga8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga7">DrawBox</a> (multivector P, multivector A, multivector B, multivector C, list CornerColorList)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draws a box.  <a href="#ga7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga9">DrawCircle</a> (multivector P, multivector N, scalar Rad)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draws a circle.  <a href="#ga9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">vertexlist&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga10">DrawCircleSurface</a> (list LMV, list LCol, counter DoDraw)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draws the surface spanned by a set of circles.  <a href="#ga10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga15">DrawCone</a> (multivector P, multivector A, scalar Rad)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draws a cone.  <a href="#ga15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">vertexlist&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga11">DrawCylinder</a> (multivector P, multivector D, scalar Radius, counter DoDraw)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draws an open cylinder.  <a href="#ga11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga12">DrawDisk</a> (multivector P, multivector A, multivector B, scalar Rad, counter Short)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draws a partial disk.  <a href="#ga12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga16">DrawEllipse</a> (multivector P, multivector A, multivector B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draws an ellipse.  <a href="#ga16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga17">DrawEllipsoid</a> (multivector P, multivector A, multivector B, multivector C)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draws an ellipsoid.  <a href="#ga17"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga13">DrawIcosahedron</a> (multivector vC, scalar dRadius, counter iPower, counter bSolid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draws an icosahedron.  <a href="#ga13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga19">DrawLine</a> (scalar ax, scalar ay, scalar az, scalar bx, scalar by, scalar bz)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draws a line.  <a href="#ga19"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga18">DrawLine</a> (multivector A, multivector B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draws a line.  <a href="#ga18"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">vertexlist&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga14">DrawLineSurface</a> (list LMV, list LCol, counter DoDraw)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draws the surface spanned by a set of lines.  <a href="#ga14"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga21">DrawPlane</a> (scalar cx, scalar cy, scalar cz, scalar ax, scalar ay, scalar az, scalar bx, scalar by, scalar bz, scalar Rad)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draws a plane.  <a href="#ga21"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga20">DrawPlane</a> (multivector C, multivector A, multivector B, scalar Rad)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draws a plane.  <a href="#ga20"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga23">DrawPoint</a> (scalar x, scalar y, scalar z)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draws a point.  <a href="#ga23"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga22">DrawPoint</a> (multivector A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draws a point.  <a href="#ga22"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">vertexlist&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga24">DrawPointGrid</a> (counter CountX, counter CountY, list LMV, list LCol, counter DoDraw, counter NegNormals, list LNorm)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draws a surface grid over a 2-dimensional set of points.  <a href="#ga24"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">vertexlist&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga25">DrawPointList</a> (list LMV, list LCol, counter DoDraw, counter NegNormals, list LNorm)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draws a line through a set of points.  <a href="#ga25"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">vertexlist&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga26">DrawPointSurface</a> (counter CountX, counter CountY, list LMV, list LCol, counter DoDraw, counter NegNormals, list LNorm)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draws a surface over a 2-dimensional set of points.  <a href="#ga26"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga27">DrawSphere</a> (multivector P, scalar Rad)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draws a sphere.  <a href="#ga27"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga28">DrawText</a> (multivector A, string Text)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draws a simple text.  <a href="#ga28"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga30">DrawTriangle</a> (multivector A, multivector B, multivector C)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draws a triangle.  <a href="#ga30"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga29">DrawTriangle</a> (scalar ax, scalar ay, scalar az, scalar bx, scalar by, scalar bz, scalar cx, scalar cy, scalar cz)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draws a triangle.  <a href="#ga29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga31">EnableAbsTexCoords</a> (counter bVal)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables or disables the use of absolute texture coordinates.  <a href="#ga31"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga32">EnableFog</a> (counter bEnable)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables or disables fog.  <a href="#ga32"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga33">EnableSmoothLine</a> (counter IsSmooth)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables anti-aliasing for lines.  <a href="#ga33"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga34">EnableSmoothPoint</a> (counter IsSmooth)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables anti-aliasing for points.  <a href="#ga34"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga35">EndOverlay</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ends an overlay block.  <a href="#ga35"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga36">EndView</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exit the actual view.  <a href="#ga36"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">counter&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga37">GetLineWidth</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the width of lines.  <a href="#ga37"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">counter&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga38">GetPointSize</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the size of points.  <a href="#ga38"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga39">Offset</a> (multivector A, multivector X, scalar scale)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function draw multivector <em>A</em> at the offset given by multivector <em>X</em> and scaled to <em>scale</em>. Use this function, for example, to draw plane or lines at particular positions.  <a href="#ga39"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">vertexlist&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga43">Plot</a> (list A, list L1, list L2, scalar S)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draw a point-valued 2D-function, i.e. a surface, with associated colors and normals.  <a href="#ga43"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">vertexlist&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga42">Plot</a> (list A, list L)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draw a point-, circle- or line-valued 1D-function with varying colors.  <a href="#ga42"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">vertexlist&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga41">Plot</a> (multivector F, list L1, list L2, scalar S)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draw a point-valued 2D-function, i.e. a surface.  <a href="#ga41"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">vertexlist&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga40">Plot</a> (multivector F, list L)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draw a point-, circle- or line-valued 1D-function.  <a href="#ga40"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga44">PopFrame</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Restore saved projection matrix from the stack.  <a href="#ga44"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga45">PushFrame</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save current projection matrix to a stack.  <a href="#ga45"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga46">RotateFrame</a> (multivector R)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotates the drawing frame.  <a href="#ga46"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga47">RotateView</a> (multivector R)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotates the projectview matrix of OpenGl.  <a href="#ga47"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga48">SetArrowShape</a> (scalar dLength, scalar dAngle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the shape in which arrows are drawn.  <a href="#ga48"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga49">SetFogColor</a> (color colFog)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the color of fog.  <a href="#ga49"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga50">SetFogDensity</a> (scalar dDensity)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the density of fog.  <a href="#ga50"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga51">SetFrameOrigin</a> (scalar x, scalar y, scalar z)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the origin of the drawing frame.  <a href="#ga51"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga52">SetFrameRotor</a> (multivector R)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the rotation of the drawing frame.  <a href="#ga52"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga53">SetLineWidth</a> (scalar Width)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the width of lines in pixel.  <a href="#ga53"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga54">SetMode</a> (counter mode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets one or a number of drawing modes.  <a href="#ga54"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga55">SetPlotMode</a> (counter mode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the plot mode for the function <a class="el" href="group__grp__DrawFunc.html#ga40">Plot()</a>.  <a href="#ga55"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga56">SetPointSize</a> (scalar Size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the size of points in pixel.  <a href="#ga56"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga57">SetTextSize</a> (counter Size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the size of text drawn with <a class="el" href="group__grp__DrawFunc.html#ga28">DrawText()</a>.  <a href="#ga57"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga58">SetTexture</a> (image Img)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the texture for texture mapping, or disables texture mapping.  <a href="#ga58"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga59">SetTextureRepeat</a> (scalar dFac)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the texture repetition factor.  <a href="#ga59"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga60">SetViewAngle</a> (scalar a)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the perspective angle which affects the modelview.  <a href="#ga60"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga61">SetVisWinSize</a> (counter iWidth, counter iHeight)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the size of the visualization window.  <a href="#ga61"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga62">StartOverlay</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starts an overlay block.  <a href="#ga62"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga63">StartView</a> (scalar x, scalar y, scalar w, scalar h)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start a new view.  <a href="#ga63"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga65">TranslateFrame</a> (multivector T)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Translates the drawing frame.  <a href="#ga65"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga64">TranslateFrame</a> (scalar x, scalar y, scalar z)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Translates the drawing frame.  <a href="#ga64"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga67">TranslateView</a> (multivector T)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Translate the projectview matrix of OpenGl.  <a href="#ga67"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__DrawFunc.html#ga66">TranslateView</a> (scalar x, scalar y, scalar z)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Translate the projectview matrix of OpenGl.  <a href="#ga66"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Functions that draw geometric entities or influence the way they are visualized.<hr><h2>Function Documentation</h2>
<a class="anchor" name="ga0"></a><!-- doxytag: member="func_Draw.dox::AddFrameOrigin" ref="ga0" args="(scalar x, scalar y, scalar z)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void AddFrameOrigin           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>z</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Adds a vector to the current origin of the drawing frame. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>Displacement x-coordinate of frame origin. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>Displacement y-coordinate of frame origin. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>Displacement z-coordinate of frame origin.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v1.4</dd></dl>
This allows you to move the origin of the basis frame into which all entities are drawn.    </td>
  </tr>
</table>
<a class="anchor" name="ga1"></a><!-- doxytag: member="func_Draw.dox::AddFrameRotor" ref="ga1" args="(multivector R)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void AddFrameRotor           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">multivector&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>R</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Adds a rotation to the drawing frame. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>R</em>&nbsp;</td><td>A rotor giving the rotation of the frame.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v1.4</dd></dl>
This allows you to change the orientation of the basis frame relative to its current orientation. The rotor <em>R</em> is multiplied from the left to the current rotor.    </td>
  </tr>
</table>
<a class="anchor" name="ga3"></a><!-- doxytag: member="func_Draw.dox::Color" ref="ga3" args="(scalar r, scalar g, scalar b, scalar a)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">color Color           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>g</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>a</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Generate a color variable. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>r</em>&nbsp;</td><td>The red color component. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>g</em>&nbsp;</td><td>The green color component. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>The blue color component. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>The alpha (translucency) color component.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A color variable that can be applied to the visualization state-machine via the colon operator (<code>:</code>).</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v1.0</dd></dl>
The color components are clamped to the range [0,1]. That is, if you pass a value outside this range it is changed to the nearest element of the range. <b>See script</b> <code>Color1.clu</code> for a nice example. The last parameter (the alpha component) gives the translucency of an object. If alpha is one, then the object is completely opaque. If alpha is zero, then the object is completely transparent.    </td>
  </tr>
</table>
<a class="anchor" name="ga2"></a><!-- doxytag: member="func_Draw.dox::Color" ref="ga2" args="(scalar r, scalar g, scalar b)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">color Color           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>g</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>b</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Generate a color variable. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>r</em>&nbsp;</td><td>The red color component. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>g</em>&nbsp;</td><td>The green color component. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>The blue color component.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A color variable that can be applied to the visualization state-machine via the colon operator (<code>:</code>).</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v1.0</dd></dl>
<dl compact><dt><b>Attention:</b></dt><dd>From CLUCalc v3.0.0 onwards you can create a code-line defining a color from a color chooser via the menu in the editor window. Also, if you place your cursor on the word "Color" of a Color-function call, and select the appropriate menu item, the color chooser will modify the code-line.</dd></dl>
The color components are clamped to the range [0,1]. That is, if you pass a value outside this range it is changed to the nearest element of the range. <b>See script</b> <code>Color1.clu</code> for a nice example.<p>
For example, <div class="fragment"><pre class="fragment"><a class="code" href="group__grp__GAFunc.html#ga7">DefVarsE3</a>();

?MyCol = <a class="code" href="group__grp__DrawFunc.html#ga2">Color</a>(0.1, 0.4, 0.6);
:e1 :MyCol;
</pre></div><p>
produces the output <div class="fragment"><pre class="fragment">MyCol = (0.1, 0.4, 0.6)
</pre></div>    </td>
  </tr>
</table>
<a class="anchor" name="ga4"></a><!-- doxytag: member="func_Draw.dox::DrawArc" ref="ga4" args="(multivector P, multivector A, multivector B, scalar Rad, counter Short)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void DrawArc           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">multivector&nbsp;</td>
          <td class="mdname" nowrap> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>multivector&nbsp;</td>
          <td class="mdname" nowrap> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>multivector&nbsp;</td>
          <td class="mdname" nowrap> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>Rad</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>counter&nbsp;</td>
          <td class="mdname" nowrap> <em>Short</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Draws an arc. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>Vector giving origin of arc. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>Vector giving start point of arc. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>B</em>&nbsp;</td><td>Vector giving end point of arc. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Rad</em>&nbsp;</td><td>Radius of arc. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Short</em>&nbsp;</td><td>(<b>optional</b>) Boolean flag. If set to 1 it indicates that the arc along the shortest path from <em>A</em> to <em>B</em> is to be drawn (default). Otherwise, the arc is drawn along the longer path.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v1.4</dd></dl>
Draws an arc in the plane passing through <em>P</em> and spanned by <em>P</em> - <em>A</em> and <em>P</em> - <em>B</em>. The origin of the arc is at <em>P</em> and its radius is given by <em>Rad</em>. The flag <em>Short</em> allows you to draw either the arc from <em>A</em> to <em>B</em> along the short path or along the long path. Here is an example.<p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__grp__GAFunc.html#ga7">DefVarsE3</a>();

:<a class="code" href="group__grp__ColVars.html#ga2">Green</a>;
:P = e2;

:<a class="code" href="group__grp__ColVars.html#ga1">Red</a>;
:A = e1 + e2;

:<a class="code" href="group__grp__ColVars.html#ga3">Blue</a>;
:B = e3 + e2;

:<a class="code" href="group__grp__ColVars.html#ga6">Magenta</a>;
<a class="code" href="group__grp__DrawFunc.html#ga4">DrawArc</a>(P, A, B, 1);

:<a class="code" href="group__grp__ColVars.html#ga4">Cyan</a>;
<a class="code" href="group__grp__DrawFunc.html#ga4">DrawArc</a>(P, A, B, 1, 0);
</pre></div><p>
This script generates the following image.<p>
<div align="center">
<img src="ArcTest2_img1.jpg" alt="ArcTest2_img1.jpg">
</div>
    </td>
  </tr>
</table>
<a class="anchor" name="ga6"></a><!-- doxytag: member="func_Draw.dox::DrawArrow" ref="ga6" args="(scalar ax, scalar ay, scalar az, scalar bx, scalar by, scalar bz)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void DrawArrow           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>ax</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>ay</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>az</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>bx</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>by</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>bz</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Draws an arrow. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ax</em>&nbsp;</td><td>x-coordinate of start point of arrow. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ay</em>&nbsp;</td><td>y-coordinate of start point of arrow. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>az</em>&nbsp;</td><td>z-coordinate of start point of arrow.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bx</em>&nbsp;</td><td>x-coordinate of end point of arrow. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>by</em>&nbsp;</td><td>y-coordinate of end point of arrow. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bz</em>&nbsp;</td><td>z-coordinate of end point of arrow.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v1.4</dd></dl>
Draws an arrow from (<em>ax</em>, <em>ay</em>, <em>az</em>) to (<em>bx</em>, <em>by</em>, <em>bz</em>).    </td>
  </tr>
</table>
<a class="anchor" name="ga5"></a><!-- doxytag: member="func_Draw.dox::DrawArrow" ref="ga5" args="(multivector A, multivector B)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void DrawArrow           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">multivector&nbsp;</td>
          <td class="mdname" nowrap> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>multivector&nbsp;</td>
          <td class="mdname" nowrap> <em>B</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Draws an arrow. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>Multivector giving start point of the arrow. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>B</em>&nbsp;</td><td>Multivector giving end point of the arrow.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v1.4</dd></dl>
Draws an arrow from position of <em>A</em> to position of <em>B</em>.    </td>
  </tr>
</table>
<a class="anchor" name="ga8"></a><!-- doxytag: member="func_Draw.dox::DrawBox" ref="ga8" args="(multivector P, multivector A, multivector B, scalar Depth, list CornerColorList)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void DrawBox           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">multivector&nbsp;</td>
          <td class="mdname" nowrap> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>multivector&nbsp;</td>
          <td class="mdname" nowrap> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>multivector&nbsp;</td>
          <td class="mdname" nowrap> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>Depth</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>list&nbsp;</td>
          <td class="mdname" nowrap> <em>CornerColorList</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Draws a box. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>Multivector giving center position of box. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>Multivector giving first edge direction and length. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>B</em>&nbsp;</td><td>Multivector giving second edge direction and length. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Depth</em>&nbsp;</td><td>Scalar giving depth of box. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CornerColorList</em>&nbsp;</td><td>(<b>optional</b>) List of eight colors for the corners of the box.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v2.0</dd></dl>
Draws a box centered on <em>P</em>, with edge directions <em>A</em>, <em>B</em>. The third edge direction is perpendicular to <em>A</em> and <em>B</em> and has a length given by <em>Depth</em>. The optional list of colors, draws the corners of the box in the respective colors and uses smooth color shading between the corners.    </td>
  </tr>
</table>
<a class="anchor" name="ga7"></a><!-- doxytag: member="func_Draw.dox::DrawBox" ref="ga7" args="(multivector P, multivector A, multivector B, multivector C, list CornerColorList)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void DrawBox           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">multivector&nbsp;</td>
          <td class="mdname" nowrap> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>multivector&nbsp;</td>
          <td class="mdname" nowrap> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>multivector&nbsp;</td>
          <td class="mdname" nowrap> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>multivector&nbsp;</td>
          <td class="mdname" nowrap> <em>C</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>list&nbsp;</td>
          <td class="mdname" nowrap> <em>CornerColorList</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Draws a box. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>Multivector giving center position of box. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>Multivector giving first edge direction and length. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>B</em>&nbsp;</td><td>Multivector giving second edge direction and length. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>C</em>&nbsp;</td><td>Multivector giving third edge direction and length. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CornerColorList</em>&nbsp;</td><td>(<b>optional</b>) List of eight colors for the corners of the box.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v2.0</dd></dl>
Draws a box centered on <em>P</em>, with edge directions <em>A</em>, <em>B</em> and <em>C</em>. The optional list of colors, draws the corners of the box in the respective colors and uses smooth color shading between the corners. Here is an example. The script<p>
<div class="fragment"><pre class="fragment">    <a class="code" href="group__grp__GAFunc.html#ga7">DefVarsE3</a>();
    lCol = [ <a class="code" href="group__grp__ColVars.html#ga1">Red</a>, <a class="code" href="group__grp__ColVars.html#ga6">Magenta</a>, <a class="code" href="group__grp__ColVars.html#ga3">Blue</a>, <a class="code" href="group__grp__ColVars.html#ga4">Cyan</a>, <a class="code" href="group__grp__ColVars.html#ga2">Green</a>, <a class="code" href="group__grp__ColVars.html#ga5">Yellow</a>, <a class="code" href="group__grp__ColVars.html#ga8">White</a>, <a class="code" href="group__grp__ColVars.html#ga29">DWhite</a> ];
    <a class="code" href="group__grp__DrawFunc.html#ga7">DrawBox</a>(<span class="keywordtype">id</span>, e1, e2, e3, lCol);
</pre></div><p>
produces the visualization<p>
<div align="center">
<img src="BoxEx1.jpg" alt="BoxEx1.jpg">
</div>
    </td>
  </tr>
</table>
<a class="anchor" name="ga9"></a><!-- doxytag: member="func_Draw.dox::DrawCircle" ref="ga9" args="(multivector P, multivector N, scalar Rad)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void DrawCircle           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">multivector&nbsp;</td>
          <td class="mdname" nowrap> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>multivector&nbsp;</td>
          <td class="mdname" nowrap> <em>N</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>Rad</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Draws a circle. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>Vector giving origin of circle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>N</em>&nbsp;</td><td>Vector giving normal of plane in which circle lies. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Rad</em>&nbsp;</td><td>Radius of circle</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v1.4</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga10"></a><!-- doxytag: member="func_Draw.dox::DrawCircleSurface" ref="ga10" args="(list LMV, list LCol, counter DoDraw)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">vertexlist DrawCircleSurface           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">list&nbsp;</td>
          <td class="mdname" nowrap> <em>LMV</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>list&nbsp;</td>
          <td class="mdname" nowrap> <em>LCol</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>counter&nbsp;</td>
          <td class="mdname" nowrap> <em>DoDraw</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Draws the surface spanned by a set of circles. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>LMV</em>&nbsp;</td><td>A list of multivectors in conformal space representing circles. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LCol</em>&nbsp;</td><td>A list with one color for each circle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DoDraw</em>&nbsp;</td><td>(<b>optional</b>) A boolean flag indicating whether the surface is to be drawn directly (= 1, default), or not.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A vertex list representing the surface spanned by the circles. This vertex list can be useful to draw the surface at some later stage without having to execute this function.</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v1.4</dd></dl>
This function only works with multivectors that represent circles in conformal space. How the surface connecting two circles is drawn, depends on their normals. In the following simple example, a nice effect is obtained by negating the normal of the central circle. Also see the script <code>KleinBottle.clu</code> which draws a Klein bottle.<p>
<div class="fragment"><pre class="fragment"><span class="comment">// Switch on anti-aliasing for lines</span>
<a class="code" href="group__grp__DrawFunc.html#ga33">EnableSmoothLine</a>(1);

<span class="comment">// Define the standard basis vector variables</span>
<span class="comment">// for conformal space.</span>
<a class="code" href="group__grp__GAFunc.html#ga8">DefVarsN3</a>();

<span class="comment">// Do not show the frame box</span>
<a class="code" href="group__grp__VarEnv.html#ga3">_FrameBoxSize</a> = 0;

<span class="comment">// Define three spheres</span>
S1 = <a class="code" href="group__grp__GAFunc.html#ga29">SphereN3</a>(0,0,0, 1);
S2 = <a class="code" href="group__grp__GAFunc.html#ga29">SphereN3</a>(0.1,0.5,0, 1);
S3 = <a class="code" href="group__grp__GAFunc.html#ga29">SphereN3</a>(0.2,0.7,0, 1);

<span class="comment">// Draw all spheres with a solid surface</span>
:<a class="code" href="group__grp__MVStype__N3.html#ga3">N3_SOLID</a>;
<span class="comment">// Use a transparent color</span>
:<a class="code" href="group__grp__DrawFunc.html#ga2">Color</a>(0.198, 0.264, 1.000, 0.8);
<span class="comment">// Draw a fourth sphere, whose x-position </span>
<span class="comment">// can also be influenced by the user in</span>
<span class="comment">// mouse mode one with the right </span>
<span class="comment">// mouse button. </span>
:S4 = <a class="code" href="group__grp__GAFunc.html#ga29">SphereN3</a>(<a class="code" href="group__grp__Misc.html#ga17">Mouse</a>(1,2,1),0.8,0, 1);

<span class="comment">// Set the color to red</span>
:<a class="code" href="group__grp__ColVars.html#ga1">Red</a>;
<span class="comment">// Intersect spheres 1 and 2, and</span>
<span class="comment">// draw intersection circle</span>
:C1 = *S1 . S2;

<span class="comment">// Set Color to green</span>
:Green;
<span class="comment">// Intersect spheres 2 and 3, and</span>
<span class="comment">// draw intersection circle</span>
<span class="comment">// If you remove the minus sign in this equation,</span>
<span class="comment">// you obtain a completely different surface.</span>
:C2 = -*S2 . S3;

<span class="comment">// Set Color to magenta</span>
:Magenta;
<span class="comment">// Intersect spheres 3 and 4, and</span>
<span class="comment">// draw intersection circle</span>
:C3 = *S3 . S4;

<span class="comment">// Create a list of circles</span>
LCircle = [C1, C2, C3];

<span class="comment">// Create a list of colors</span>
LColor = [<a class="code" href="group__grp__ColVars.html#ga1">Red</a>, Green, Magenta];

<span class="comment">// Draw surface spanned by circles.</span>
<a class="code" href="group__grp__DrawFunc.html#ga10">DrawCircleSurface</a>(LCircle, LColor);
</pre></div><p>
This script generates the following visualization.<p>
<div align="center">
<img src="CircleSurface_img1.jpg" alt="CircleSurface_img1.jpg">
</div>
<p>
If you change the line <code>:C2 = -*S2 . S3</code> into <code>:C2 = *S2 . S3</code>, you obtain the following visualization.<p>
<div align="center">
<img src="CircleSurface_img2.jpg" alt="CircleSurface_img2.jpg">
</div>
    </td>
  </tr>
</table>
<a class="anchor" name="ga15"></a><!-- doxytag: member="func_Draw.dox::DrawCone" ref="ga15" args="(multivector P, multivector A, scalar Rad)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void DrawCone           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">multivector&nbsp;</td>
          <td class="mdname" nowrap> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>multivector&nbsp;</td>
          <td class="mdname" nowrap> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>Rad</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Draws a cone. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>Origin of cone. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>Direction and length of cone. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Rad</em>&nbsp;</td><td>Radius of cone at the opening.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v1.4</dd></dl>
Draws a cone whose origin is in <em>P</em>. The cone opens in the direction of <em>A</em> and has the length of <em>A</em>. The radius at the opening of the cone is given by <em>Rad</em>.    </td>
  </tr>
</table>
<a class="anchor" name="ga11"></a><!-- doxytag: member="func_Draw.dox::DrawCylinder" ref="ga11" args="(multivector P, multivector D, scalar Radius, counter DoDraw)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">vertexlist DrawCylinder           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">multivector&nbsp;</td>
          <td class="mdname" nowrap> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>multivector&nbsp;</td>
          <td class="mdname" nowrap> <em>D</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>Radius</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>counter&nbsp;</td>
          <td class="mdname" nowrap> <em>DoDraw</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Draws an open cylinder. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>A multivector that specifies the center of the cylinder bottom. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>D</em>&nbsp;</td><td>A multivector that specifies direction and length. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Radius</em>&nbsp;</td><td>A scalar defining the radius. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DoDraw</em>&nbsp;</td><td>(<b>optional</b>) A boolean flag indicating whether the cylinder is to be drawn directly (= 1, default), or not. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Slices</em>&nbsp;</td><td>(<b>optional</b>) An integer value in the range of 3 to 360, which gives the number of slices in which a cylinder is separated. The default is 72.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A vertex list representing the surface of the cylinder.</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v2.0</dd></dl>
Setting the number of slices to a lower value can be useful if the cylinders drawn appear rather small in the visualization. Less slices will then not change the visual quality, while speeding up the visualization considerably. Here's an example,<p>
<div class="fragment"><pre class="fragment">    <a class="code" href="group__grp__VarEnv.html#ga1">_BGColor</a> = White;
    d = 1.1;
    D = <a class="code" href="group__grp__GAFunc.html#ga39">VecN3</a>(0,0.5,0);
    <a class="code" href="group__grp__DrawFunc.html#ga11">DrawCylinder</a>( <a class="code" href="group__grp__GAFunc.html#ga39">VecN3</a>( -2*d,0,0 ), D, 1 ):Blue;
    <a class="code" href="group__grp__DrawFunc.html#ga11">DrawCylinder</a>( <a class="code" href="group__grp__GAFunc.html#ga39">VecN3</a>( 0,0,0 ), D, 1 ):<a class="code" href="group__grp__ColVars.html#ga9">Black</a>;
    <a class="code" href="group__grp__DrawFunc.html#ga11">DrawCylinder</a>( <a class="code" href="group__grp__GAFunc.html#ga39">VecN3</a>( 2*d,0,0 ), D, 1 ):<a class="code" href="group__grp__ColVars.html#ga1">Red</a>;
    <a class="code" href="group__grp__DrawFunc.html#ga11">DrawCylinder</a>( <a class="code" href="group__grp__GAFunc.html#ga39">VecN3</a>( -d,0,-d ), D, 1 ):Yellow;
    <a class="code" href="group__grp__DrawFunc.html#ga11">DrawCylinder</a>( <a class="code" href="group__grp__GAFunc.html#ga39">VecN3</a>( d,0,-d ), D, 1 ):Green;
</pre></div><p>
that produces a kind of olympic 'cylinders'.<p>
<div align="center">
<img src="DrawCylinder_img1.jpg" alt="DrawCylinder_img1.jpg">
</div>
    </td>
  </tr>
</table>
<a class="anchor" name="ga12"></a><!-- doxytag: member="func_Draw.dox::DrawDisk" ref="ga12" args="(multivector P, multivector A, multivector B, scalar Rad, counter Short)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void DrawDisk           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">multivector&nbsp;</td>
          <td class="mdname" nowrap> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>multivector&nbsp;</td>
          <td class="mdname" nowrap> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>multivector&nbsp;</td>
          <td class="mdname" nowrap> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>Rad</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>counter&nbsp;</td>
          <td class="mdname" nowrap> <em>Short</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Draws a partial disk. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>Vector giving origin of disk. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>Vector giving start point of disk. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>B</em>&nbsp;</td><td>Vector giving end point of disk. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Rad</em>&nbsp;</td><td>Radius of disk. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Short</em>&nbsp;</td><td>(<b>optional</b>) Boolean flag. If set to 1 it indicates that the disk withn the arc along the shortest path from <em>A</em> to <em>B</em> is to be drawn (default). Otherwise, the disk is drawn along the longer path.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v2.0</dd></dl>
This function works just like <a class="el" href="group__grp__DrawFunc.html#ga4">DrawArc()</a>. However, instead of just drawing an arc, it draws a partial disk whose outer border is the arc.    </td>
  </tr>
</table>
<a class="anchor" name="ga16"></a><!-- doxytag: member="func_Draw.dox::DrawEllipse" ref="ga16" args="(multivector P, multivector A, multivector B)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void DrawEllipse           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">multivector&nbsp;</td>
          <td class="mdname" nowrap> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>multivector&nbsp;</td>
          <td class="mdname" nowrap> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>multivector&nbsp;</td>
          <td class="mdname" nowrap> <em>B</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Draws an ellipse. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>Vector giving origin of ellipse. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>Vector giving first axis of ellipse. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>B</em>&nbsp;</td><td>Vector giving second axis of ellipse.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v1.5</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga17"></a><!-- doxytag: member="func_Draw.dox::DrawEllipsoid" ref="ga17" args="(multivector P, multivector A, multivector B, multivector C)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void DrawEllipsoid           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">multivector&nbsp;</td>
          <td class="mdname" nowrap> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>multivector&nbsp;</td>
          <td class="mdname" nowrap> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>multivector&nbsp;</td>
          <td class="mdname" nowrap> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>multivector&nbsp;</td>
          <td class="mdname" nowrap> <em>C</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Draws an ellipsoid. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>Vector giving origin of ellipse. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>Vector giving first axis of ellipsoid. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>B</em>&nbsp;</td><td>Vector giving second axis of ellipsoid. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>C</em>&nbsp;</td><td>Vector giving third axis of ellipsoid.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v2.0</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga13"></a><!-- doxytag: member="func_Draw.dox::DrawIcosahedron" ref="ga13" args="(multivector vC, scalar dRadius, counter iPower, counter bSolid)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void DrawIcosahedron           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">multivector&nbsp;</td>
          <td class="mdname" nowrap> <em>vC</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>dRadius</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>counter&nbsp;</td>
          <td class="mdname" nowrap> <em>iPower</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>counter&nbsp;</td>
          <td class="mdname" nowrap> <em>bSolid</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Draws an icosahedron. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vC</em>&nbsp;</td><td>Center of Icosahedron. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dRadius</em>&nbsp;</td><td>The radius of the icosahedron. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iPower</em>&nbsp;</td><td>The power of the icosahedron. Has to be &gt;= 0 and &lt;= 6. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bSolid</em>&nbsp;</td><td>If bSolid is not zero, then the icosahedron is drawn as a solid object, and as wireframe otherwise.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing.</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v.2.2</dd></dl>
This function draws an icosahedron. Note that spheres in CLUCalc are also drawn as icosahedrons. However, when you draw a sphere a pre-calculated icosahedron of a fixed power is used. Here is an example of drawing a wireframe icosahedron.<p>
<div class="fragment"><pre class="fragment">    <a class="code" href="group__grp__DrawFunc.html#ga13">DrawIcosahedron</a>(<a class="code" href="group__grp__GAFunc.html#ga36">VecE3</a>(0,0,0), 1, 3, <span class="keyword">false</span>);
</pre></div><p>
Output:<p>
<div align="center">
<img src="Icosahedron1.png" alt="Icosahedron1.png">
</div>
    </td>
  </tr>
</table>
<a class="anchor" name="ga19"></a><!-- doxytag: member="func_Draw.dox::DrawLine" ref="ga19" args="(scalar ax, scalar ay, scalar az, scalar bx, scalar by, scalar bz)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void DrawLine           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>ax</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>ay</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>az</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>bx</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>by</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>bz</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Draws a line. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ax</em>&nbsp;</td><td>x-coordinate of start point of line. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ay</em>&nbsp;</td><td>y-coordinate of start point of line. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>az</em>&nbsp;</td><td>z-coordinate of start point of line.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bx</em>&nbsp;</td><td>x-coordinate of end point of line. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>by</em>&nbsp;</td><td>y-coordinate of end point of line. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bz</em>&nbsp;</td><td>z-coordinate of end point of line.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v1.4</dd></dl>
Draws a line from (<em>ax</em>, <em>ay</em>, <em>az</em>) to (<em>bx</em>, <em>by</em>, <em>bz</em>).    </td>
  </tr>
</table>
<a class="anchor" name="ga18"></a><!-- doxytag: member="func_Draw.dox::DrawLine" ref="ga18" args="(multivector A, multivector B)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void DrawLine           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">multivector&nbsp;</td>
          <td class="mdname" nowrap> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>multivector&nbsp;</td>
          <td class="mdname" nowrap> <em>B</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Draws a line. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>Multivector giving start point of line. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>B</em>&nbsp;</td><td>Multivector giving end point of line.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v1.4</dd></dl>
Draws a line from position of <em>A</em> to position of <em>B</em>.    </td>
  </tr>
</table>
<a class="anchor" name="ga14"></a><!-- doxytag: member="func_Draw.dox::DrawLineSurface" ref="ga14" args="(list LMV, list LCol, counter DoDraw)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">vertexlist DrawLineSurface           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">list&nbsp;</td>
          <td class="mdname" nowrap> <em>LMV</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>list&nbsp;</td>
          <td class="mdname" nowrap> <em>LCol</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>counter&nbsp;</td>
          <td class="mdname" nowrap> <em>DoDraw</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Draws the surface spanned by a set of lines. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>LMV</em>&nbsp;</td><td>A list of multivectors in conformal space representing lines. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LCol</em>&nbsp;</td><td>A list with one color for each line. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DoDraw</em>&nbsp;</td><td>(<b>optional</b>) A boolean flag indicating whether the surface is to be drawn directly (= 1, default), or not.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A vertex list representing the surface spanned by the lines.</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v2.0</dd></dl>
This function only works with multivectors that represent lines in conformal space. Its usage is the same as for the function <code>DrawCircleSurface</code>. The code<p>
<div class="fragment"><pre class="fragment">    <a class="code" href="group__grp__GAFunc.html#ga8">DefVarsN3</a>();
    :<a class="code" href="group__grp__MVStyle__Global.html#ga0">IPNS</a>;
    <a class="code" href="group__grp__VarEnv.html#ga3">_FrameBoxSize</a> = 0;

    <span class="comment">// Define a line and a transformation (mvT)</span>
    mvLine = e^<a class="code" href="group__grp__GAFunc.html#ga39">VecN3</a>( 1,0,0) ^ <a class="code" href="group__grp__GAFunc.html#ga39">VecN3</a>( 2,0,0 );
    mvT = <a class="code" href="group__grp__GAFunc.html#ga31">TranslatorN3</a>( 0,0,0.2) * <a class="code" href="group__grp__GAFunc.html#ga24">RotorN3</a>( 0,0,1, 7*<a class="code" href="group__grp__MathConst.html#ga1">Pi</a>/180 );

    lmvL = []; <span class="comment">// declare empty lists for lines and colors</span>
    lcolC = [];

    <span class="comment">// create a set of lines</span>
    dNum = 40;
    i = 0;
    loop{
        <span class="keywordflow">if</span> ( i == dNum )
            <span class="keywordflow">break</span>;
        i = i + 1;
    
        mvLine =  mvT * mvLine* ~mvT;
        lmvL &lt;&lt; (mvLine * I);
        lcolC &lt;&lt; <a class="code" href="group__grp__DrawFunc.html#ga2">Color</a>( 1, <a class="code" href="group__grp__MathFunc.html#ga33">pow</a>(i/dNum,2), 0 );
    }
    
    <a class="code" href="group__grp__DrawFunc.html#ga14">DrawLineSurface</a>( lmvL, lcolC );
</pre></div><p>
generates for example the following output<p>
<div align="center">
<img src="LineSurface_img1.jpg" alt="LineSurface_img1.jpg">
</div>
    </td>
  </tr>
</table>
<a class="anchor" name="ga21"></a><!-- doxytag: member="func_Draw.dox::DrawPlane" ref="ga21" args="(scalar cx, scalar cy, scalar cz, scalar ax, scalar ay, scalar az, scalar bx, scalar by, scalar bz, scalar Rad)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void DrawPlane           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>cx</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>cy</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>cz</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>ax</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>ay</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>az</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>bx</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>by</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>bz</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>Rad</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Draws a plane. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cx</em>&nbsp;</td><td>x-coordinate of plane center. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cy</em>&nbsp;</td><td>y-coordinate of plane center. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cz</em>&nbsp;</td><td>z-coordinate of plane center.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ax</em>&nbsp;</td><td>x-coordinate of first base vector of plane. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ay</em>&nbsp;</td><td>y-coordinate of first base vector of plane. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>az</em>&nbsp;</td><td>z-coordinate of first base vector of plane.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bx</em>&nbsp;</td><td>x-coordinate of second base vector of plane. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>by</em>&nbsp;</td><td>y-coordinate of second base vector of plane. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bz</em>&nbsp;</td><td>z-coordinate of second base vector of plane.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Rad</em>&nbsp;</td><td>(optional) Radius of disk. If this is zero or not given plane is drawn as a rectangle.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v1.4</dd></dl>
Draws a plane centered on (<em>cx</em>, <em>cy</em>, <em>cz</em>) with basis vectors (<em>ax</em>, <em>ay</em>, <em>az</em>) and (<em>bx</em>, <em>by</em>, <em>bz</em>). The side length of the rectangle drawn is just the magnitude of the respective basis vectors. If <em>Rad</em> is not zero, then a disk with radius <em>Rad</em> is drawn instead.    </td>
  </tr>
</table>
<a class="anchor" name="ga20"></a><!-- doxytag: member="func_Draw.dox::DrawPlane" ref="ga20" args="(multivector C, multivector A, multivector B, scalar Rad)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void DrawPlane           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">multivector&nbsp;</td>
          <td class="mdname" nowrap> <em>C</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>multivector&nbsp;</td>
          <td class="mdname" nowrap> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>multivector&nbsp;</td>
          <td class="mdname" nowrap> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>Rad</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Draws a plane. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>C</em>&nbsp;</td><td>Multivector giving center of plane. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>Multivector giving first basis vector of plane. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>B</em>&nbsp;</td><td>Multivector giving second basis vector of plane. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Rad</em>&nbsp;</td><td>(optional) Radius of disk. If this is zero or not given plane is drawn as a rectangle.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v1.4</dd></dl>
Draws a plane centered on <em>C</em> with basis vectors <em>A</em> and <em>B</em>. The side length of the rectangle drawn is just the magnitude of the respective basis vectors. If <em>Rad</em> is not zero, then a disk with radius <em>Rad</em> is drawn instead.    </td>
  </tr>
</table>
<a class="anchor" name="ga23"></a><!-- doxytag: member="func_Draw.dox::DrawPoint" ref="ga23" args="(scalar x, scalar y, scalar z)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void DrawPoint           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>z</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Draws a point. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>x-coordinate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>y-coordinate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>z</em>&nbsp;</td><td>z-coordinate</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v1.4</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga22"></a><!-- doxytag: member="func_Draw.dox::DrawPoint" ref="ga22" args="(multivector A)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void DrawPoint           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">multivector&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>A</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Draws a point. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>Multivector that represents a point Euclidean space.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v1.4</dd></dl>
If the multivector passed is a vector in projective space, say, then this vector is projected into Euclidean space and then displayed.    </td>
  </tr>
</table>
<a class="anchor" name="ga24"></a><!-- doxytag: member="func_Draw.dox::DrawPointGrid" ref="ga24" args="(counter CountX, counter CountY, list LMV, list LCol, counter DoDraw, counter NegNormals, list LNorm)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">vertexlist DrawPointGrid           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">counter&nbsp;</td>
          <td class="mdname" nowrap> <em>CountX</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>counter&nbsp;</td>
          <td class="mdname" nowrap> <em>CountY</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>list&nbsp;</td>
          <td class="mdname" nowrap> <em>LMV</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>list&nbsp;</td>
          <td class="mdname" nowrap> <em>LCol</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>counter&nbsp;</td>
          <td class="mdname" nowrap> <em>DoDraw</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>counter&nbsp;</td>
          <td class="mdname" nowrap> <em>NegNormals</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>list&nbsp;</td>
          <td class="mdname" nowrap> <em>LNorm</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Draws a surface grid over a 2-dimensional set of points. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>CountX</em>&nbsp;</td><td>Number of points along x-direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CountY</em>&nbsp;</td><td>Number of points along y-direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LMV</em>&nbsp;</td><td>A list of multivectors containing the surface points.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LCol</em>&nbsp;</td><td>(<b>optional</b>) A list of colors with one entry for each surface point. By default all surface points take on the currently active color.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DoDraw</em>&nbsp;</td><td>(<b>optional</b>) A boolean flag. If this is one (default), the surface grid is drawn directly, otherwise it is not drawn. The latter case may be useful if you want to draw the vertex list returned at a later stage.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NegNormals</em>&nbsp;</td><td>(<b>optional</b>) A boolean flag. If this is one, the surface normals are negated. Otherwise (the default) they are not.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LNorm</em>&nbsp;</td><td>(<b>optional</b>) A list of multivectors containing one surface normal for each point. If this list is not given, the surface normals are evaluated automatically. Note that the algorithm used for this automatic generation of surface normals is probably not the best one currently.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A vertex list representing the surface grid to be drawn.</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v1.4</dd></dl>
<dl compact><dt><b>Attention:</b></dt><dd>The syntax of this function is preliminary and may change slightly in a future version.</dd></dl>
With this function you can draw arbitrary vector valued, 2-dimensional functions. One important feature of this function is, that it returns a vertex list of the surface gird to be drawn. You can draw the vertex list by simply applying the colon operator (:) to it. This is much quicker than calling the <code>DrawPointGrid</code> function each time you want to draw the surface grid.<p>
In order to get a surface grid drawn, you first need to generate a list of surface points. They have to be ordered row-wise. That is, the list of points contains first all points of the first row, then the points of the second row, etc. See function <a class="el" href="group__grp__DrawFunc.html#ga26">DrawPointSurface()</a> for an example.    </td>
  </tr>
</table>
<a class="anchor" name="ga25"></a><!-- doxytag: member="func_Draw.dox::DrawPointList" ref="ga25" args="(list LMV, list LCol, counter DoDraw, counter NegNormals, list LNorm)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">vertexlist DrawPointList           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">list&nbsp;</td>
          <td class="mdname" nowrap> <em>LMV</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>list&nbsp;</td>
          <td class="mdname" nowrap> <em>LCol</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>counter&nbsp;</td>
          <td class="mdname" nowrap> <em>DoDraw</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>counter&nbsp;</td>
          <td class="mdname" nowrap> <em>NegNormals</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>list&nbsp;</td>
          <td class="mdname" nowrap> <em>LNorm</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Draws a line through a set of points. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>LMV</em>&nbsp;</td><td>A list of multivectors containing the points.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LCol</em>&nbsp;</td><td>(<b>optional</b>) A list of colors with one entry for each point. By default all points take on the currently active color.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DoDraw</em>&nbsp;</td><td>(<b>optional</b>) A boolean flag. If this is one (default), the line is drawn directly, otherwise it is not drawn. The latter case may be useful if you want to draw the vertex list returned at a later stage.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NegNormals</em>&nbsp;</td><td>(<b>optional</b>) A boolean flag. If this is one, the normals are negated. Otherwise (the default) they are not.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LNorm</em>&nbsp;</td><td>(<b>optional</b>) A list of multivectors containing one normal for each point. If this list is not given, the normals are evaluated automatically. To think of normals in a one dimensional function may seem strange. However, somehow the reflectance needs to be evaluated, so normals have to be given in some form. By default normals are evaluated that are perpendicular to the plane the line is drawn in.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A vertex list representing the line function to be drawn.</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v1.4</dd></dl>
<dl compact><dt><b>Attention:</b></dt><dd>The syntax of this function is preliminary and may change slightly in a future version.</dd></dl>
With this function you can draw arbitrary vector valued, 1-dimensional functions. One important feature of this function is, that it returns a vertex list of the surface gird to be drawn. You can draw the vertex list by simply applying the colon operator (:) to it. This is much quicker than calling the <code>DrawPointList</code> function each time you want to draw the function.<p>
This function can be used to replace the <a class="el" href="group__grp__DrawFunc.html#ga40">Plot()</a> function. However, you will have to write the loop that generate the points yourself. See function <a class="el" href="group__grp__DrawFunc.html#ga26">DrawPointSurface()</a> for an example of how to generate such a list.    </td>
  </tr>
</table>
<a class="anchor" name="ga26"></a><!-- doxytag: member="func_Draw.dox::DrawPointSurface" ref="ga26" args="(counter CountX, counter CountY, list LMV, list LCol, counter DoDraw, counter NegNormals, list LNorm)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">vertexlist DrawPointSurface           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">counter&nbsp;</td>
          <td class="mdname" nowrap> <em>CountX</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>counter&nbsp;</td>
          <td class="mdname" nowrap> <em>CountY</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>list&nbsp;</td>
          <td class="mdname" nowrap> <em>LMV</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>list&nbsp;</td>
          <td class="mdname" nowrap> <em>LCol</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>counter&nbsp;</td>
          <td class="mdname" nowrap> <em>DoDraw</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>counter&nbsp;</td>
          <td class="mdname" nowrap> <em>NegNormals</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>list&nbsp;</td>
          <td class="mdname" nowrap> <em>LNorm</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Draws a surface over a 2-dimensional set of points. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>CountX</em>&nbsp;</td><td>Number of points along x-direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CountY</em>&nbsp;</td><td>Number of points along y-direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LMV</em>&nbsp;</td><td>A list of multivectors containing the surface points.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LCol</em>&nbsp;</td><td>(<b>optional</b>) A list of colors with one entry for each surface point. By default all surface points take on the currently active color.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DoDraw</em>&nbsp;</td><td>(<b>optional</b>) A boolean flag. If this is one (default), the surface is drawn directly, otherwise it is not drawn. The latter case may be useful if you want to draw the vertex list returned at a later stage.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NegNormals</em>&nbsp;</td><td>(<b>optional</b>) A boolean flag. If this is one, the surface normals are negated. Otherwise (the default) they are not.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LNorm</em>&nbsp;</td><td>(<b>optional</b>) A list of multivectors containing one surface normal for each point. If this list is not given, the surface normals are evaluated automatically. Note that the algorithm used for this automatic generation of surface normals is probably not the best one currently.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A vertex list representing the surface to be drawn.</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v1.4</dd></dl>
<dl compact><dt><b>Attention:</b></dt><dd>The syntax of this function is preliminary and may change slightly in a future version.</dd></dl>
With this function you can draw arbitrary vector valued, 2-dimensional functions. One important feature of this function is, that it returns a vertex list of the surface to be drawn. You can draw the vertex list by simply applying the colon operator (:) to it. This is much quicker than calling the <code>DrawPointSurface</code> function each time you want to draw the surface.<p>
In order to get a surface drawn you first need to generate a list of surface points. They have to be ordered row-wise. That is, the list of points contains first all points of the first row, then the points of the second row, etc. Here is a simple example to draw the function <img class="formulaInl" alt="$x\,y$" src="form_0.png"> .<p>
<div class="fragment"><pre class="fragment"><span class="comment">// Switch off the frame box</span>
<a class="code" href="group__grp__VarEnv.html#ga3">_FrameBoxSize</a> = 0;

<span class="comment">// Define the standard basis vector variables</span>
<span class="comment">// for Euclidean space.</span>
<a class="code" href="group__grp__GAFunc.html#ga7">DefVarsE3</a>();

<span class="comment">// The step width in x and y direction</span>
StepX = 0.1;
StepY = 0.1;

<span class="comment">// The Plot range</span>
MinX = -1;
MaxX = 1;
MinY = -1;
MaxY = 1;

<span class="comment">// Count the rows that we draw.</span>
RowCount = 0;

<span class="comment">// Reset lists</span>
LP = [];
LC = [];
LC2 = [];

<span class="comment">// Set y to initial value</span>
y = MinY;
<span class="comment">// and start a loop over y</span>
loop
{
    <span class="comment">// Check whether y is out of range</span>
    <span class="keywordflow">if</span> (y &gt; MaxY)
        <span class="keywordflow">break</span>; <span class="comment">// if yes, then end loop over y</span>
    
    <span class="comment">// Set x to its initial value</span>
    x = MinX;
    <span class="comment">// and start a loop over x</span>
    loop
    {
        <span class="comment">// check whether x is out of range</span>
        <span class="keywordflow">if</span> (x &gt; MaxX)
            <span class="keywordflow">break</span>; <span class="comment">// if yes, then end loop over x</span>

        <span class="comment">// Evaluate point a current x,y-position</span>
        A = x*e1 + y*e3 + <a class="code" href="group__grp__MathFunc.html#ga44">sin</a>(3*x)*<a class="code" href="group__grp__MathFunc.html#ga16">cos</a>(2*y)*e2;

        <span class="comment">// Evaluate color at current position</span>
        c = <a class="code" href="group__grp__MathFunc.html#ga19">exp</a>(-x*x*y*y/0.1);
        Col = <a class="code" href="group__grp__DrawFunc.html#ga2">Color</a>(c, 0, 1 - c);
    
        <span class="comment">// Evaluate color for surface grid</span>
        c = 0.9 * c;
        Col2 = <a class="code" href="group__grp__DrawFunc.html#ga2">Color</a>(c, 0, 1-c);

        <span class="comment">// Add point to list</span>
        LP &lt;&lt; A;
        <span class="comment">// Add color to list</span>
        LC &lt;&lt; Col;
        <span class="comment">// Add color to list</span>
        LC2 &lt;&lt; Col2;
        
        <span class="comment">// Increase x-position by StepX</span>
        x = x + StepX;
    }

    <span class="comment">// Increase y-position by StepY</span>
    y = y + StepY;

    <span class="comment">// Count the rows</span>
    RowCount = RowCount + 1;
}

<span class="comment">// Evaluate the columns</span>
ColCount = Len(LP) / RowCount;

<span class="comment">// Draw Surface</span>
<a class="code" href="group__grp__DrawFunc.html#ga26">DrawPointSurface</a>(ColCount, RowCount, LP, LC);

<span class="comment">// Draw Grid</span>
<a class="code" href="group__grp__DrawFunc.html#ga24">DrawPointGrid</a>(ColCount, RowCount, LP, LC2);
</pre></div><p>
This generates the following image. <div align="center">
<img src="PointSurface1_img1.jpg" alt="PointSurface1_img1.jpg">
</div>
    </td>
  </tr>
</table>
<a class="anchor" name="ga27"></a><!-- doxytag: member="func_Draw.dox::DrawSphere" ref="ga27" args="(multivector P, scalar Rad)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void DrawSphere           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">multivector&nbsp;</td>
          <td class="mdname" nowrap> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>Rad</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Draws a sphere. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>Vector giving origin of sphere. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Rad</em>&nbsp;</td><td>Radius of sphere.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v1.5</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga28"></a><!-- doxytag: member="func_Draw.dox::DrawText" ref="ga28" args="(multivector A, string Text)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void DrawText           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">multivector&nbsp;</td>
          <td class="mdname" nowrap> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>string&nbsp;</td>
          <td class="mdname" nowrap> <em>Text</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Draws a simple text. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>The position where to draw the text. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Text</em>&nbsp;</td><td>The text to draw.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v2.1</dd></dl>
Draws the given text at the given position in the currently active color and size. The font size can be set with <a class="el" href="group__grp__DrawFunc.html#ga57">SetTextSize()</a>. Here is an example,<p>
<div class="fragment"><pre class="fragment">    :A = <a class="code" href="group__grp__GAFunc.html#ga36">VecE3</a>(1,2,1);
    :<a class="code" href="group__grp__ColVars.html#ga1">Red</a>;
    <a class="code" href="group__grp__DrawFunc.html#ga57">SetTextSize</a>(2);
    <a class="code" href="group__grp__DrawFunc.html#ga28">DrawText</a>(A, A);
</pre></div><p>
This code produces the following output.<p>
<div align="center">
<img src="DrawTextEx1.jpg" alt="DrawTextEx1.jpg">
</div>
    </td>
  </tr>
</table>
<a class="anchor" name="ga30"></a><!-- doxytag: member="func_Draw.dox::DrawTriangle" ref="ga30" args="(multivector A, multivector B, multivector C)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void DrawTriangle           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">multivector&nbsp;</td>
          <td class="mdname" nowrap> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>multivector&nbsp;</td>
          <td class="mdname" nowrap> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>multivector&nbsp;</td>
          <td class="mdname" nowrap> <em>C</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Draws a triangle. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>Multivector giving first point of triangle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>B</em>&nbsp;</td><td>Multivector giving second point of triangle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>C</em>&nbsp;</td><td>Multivector giving third point of triangle.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v1.4</dd></dl>
Draws a triangle through the given points.    </td>
  </tr>
</table>
<a class="anchor" name="ga29"></a><!-- doxytag: member="func_Draw.dox::DrawTriangle" ref="ga29" args="(scalar ax, scalar ay, scalar az, scalar bx, scalar by, scalar bz, scalar cx, scalar cy, scalar cz)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void DrawTriangle           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>ax</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>ay</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>az</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>bx</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>by</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>bz</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>cx</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>cy</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>cz</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Draws a triangle. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ax</em>&nbsp;</td><td>x-coordinate of first point of triangle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ay</em>&nbsp;</td><td>y-coordinate of first point of triangle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>az</em>&nbsp;</td><td>z-coordinate of first point of triangle.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bx</em>&nbsp;</td><td>x-coordinate of second point of triangle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>by</em>&nbsp;</td><td>y-coordinate of second point of triangle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bz</em>&nbsp;</td><td>z-coordinate of second point of triangle.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cx</em>&nbsp;</td><td>x-coordinate of third point of triangle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cy</em>&nbsp;</td><td>y-coordinate of third point of triangle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cz</em>&nbsp;</td><td>z-coordinate of third point of triangle.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v1.4</dd></dl>
Draws a triangle whose corners are given by the specified points.    </td>
  </tr>
</table>
<a class="anchor" name="ga31"></a><!-- doxytag: member="func_Draw.dox::EnableAbsTexCoords" ref="ga31" args="(counter bVal)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void EnableAbsTexCoords           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">counter&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>bVal</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enables or disables the use of absolute texture coordinates. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bVal</em>&nbsp;</td><td>If <em>bVal</em> is not zero, then absolute texture coordinates are enabled and otherwise disabled.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing.</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v2.2</dd></dl>
See <a class="el" href="page_TextureMapping.html">Texture Mapping</a> for a detailed description.    </td>
  </tr>
</table>
<a class="anchor" name="ga32"></a><!-- doxytag: member="func_Draw.dox::EnableFog" ref="ga32" args="(counter bEnable)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void EnableFog           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">counter&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>bEnable</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enables or disables fog. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bEnable</em>&nbsp;</td><td>If not zero then fog is enables, otherwise disabled.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing.</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v2.2</dd></dl>
This is a direct mapping of the OpenGL fog support. Enabling fog blends objects more and more into a fog color as they are further away from the camera.    </td>
  </tr>
</table>
<a class="anchor" name="ga33"></a><!-- doxytag: member="func_Draw.dox::EnableSmoothLine" ref="ga33" args="(counter IsSmooth)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void EnableSmoothLine           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">counter&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>IsSmooth</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enables anti-aliasing for lines. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IsSmooth</em>&nbsp;</td><td>A boolean flag that either enables (1) or disables (0) anti-aliasing for lines. By default anti-aliasing is switched off.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v1.4</dd></dl>
This only affects lines.    </td>
  </tr>
</table>
<a class="anchor" name="ga34"></a><!-- doxytag: member="func_Draw.dox::EnableSmoothPoint" ref="ga34" args="(counter IsSmooth)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void EnableSmoothPoint           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">counter&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>IsSmooth</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enables anti-aliasing for points. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IsSmooth</em>&nbsp;</td><td>A boolean flag that either enables (1) or disables (0) anti-aliasing for points. By default anti-aliasing is switched off.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v1.4</dd></dl>
This only affects points.    </td>
  </tr>
</table>
<a class="anchor" name="ga35"></a><!-- doxytag: member="func_Draw.dox::EndOverlay" ref="ga35" args="(void)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void EndOverlay           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Ends an overlay block. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v1.4</dd></dl>
Each call to <a class="el" href="group__grp__DrawFunc.html#ga62">StartOverlay()</a> needs to have one call to <a class="el" href="group__grp__DrawFunc.html#ga35">EndOverlay()</a>. See <a class="el" href="group__grp__DrawFunc.html#ga62">StartOverlay()</a> for an example.    </td>
  </tr>
</table>
<a class="anchor" name="ga36"></a><!-- doxytag: member="func_Draw.dox::EndView" ref="ga36" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void EndView           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Exit the actual view. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v2.0</dd></dl>
This command quits an environment that had been begun by the function <code>StartView</code>.    </td>
  </tr>
</table>
<a class="anchor" name="ga37"></a><!-- doxytag: member="func_Draw.dox::GetLineWidth" ref="ga37" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">counter GetLineWidth           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the width of lines. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>The width with which lines are drawn.</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v2.2</dd></dl>
See also <a class="el" href="group__grp__DrawFunc.html#ga53">SetLineWidth()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="ga38"></a><!-- doxytag: member="func_Draw.dox::GetPointSize" ref="ga38" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">counter GetPointSize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the size of points. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>The size with which points are drawn.</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v2.2</dd></dl>
See also <a class="el" href="group__grp__DrawFunc.html#ga56">SetPointSize()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="ga39"></a><!-- doxytag: member="func_Draw.dox::Offset" ref="ga39" args="(multivector A, multivector X, scalar scale)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Offset           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">multivector&nbsp;</td>
          <td class="mdname" nowrap> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>multivector&nbsp;</td>
          <td class="mdname" nowrap> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>scale</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function draw multivector <em>A</em> at the offset given by multivector <em>X</em> and scaled to <em>scale</em>. Use this function, for example, to draw plane or lines at particular positions. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>The multivector to be drawn. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>X</em>&nbsp;</td><td>The offset by which the visualization of <em>A</em> is to be moved. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scale</em>&nbsp;</td><td>The scale with which the visualization is to be scaled.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v1.4</dd></dl>
See section <a class="el" href="page_WorkWithMV.html#sec_VisMV">Visualizing Multivectors</a> for more details.    </td>
  </tr>
</table>
<a class="anchor" name="ga43"></a><!-- doxytag: member="func_Draw.dox::Plot" ref="ga43" args="(list A, list L1, list L2, scalar S)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">vertexlist Plot           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">list&nbsp;</td>
          <td class="mdname" nowrap> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>list&nbsp;</td>
          <td class="mdname" nowrap> <em>L1</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>list&nbsp;</td>
          <td class="mdname" nowrap> <em>L2</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>S</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Draw a point-valued 2D-function, i.e. a surface, with associated colors and normals. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>A list containing a point-valued function and optionally also a color function and a normal function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>L1</em>&nbsp;</td><td>A list containing the first free variable and its range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>L2</em>&nbsp;</td><td>A list containing the second free variable and its range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>S</em>&nbsp;</td><td><b>(optional)</b> Length of normals.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>This function returns a vertex list containing the evaluated points of the function.</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v2.1</dd></dl>
The list <em>A</em> may contain one to four elements. Let us call the first element <em>F</em>, the second element <em>C</em>, the third element <em>N</em> and the fourth element <em>T</em>. <em>F</em> is a point valued function, <em>C</em> is a color function, <em>N</em> a normal function and <em>T</em> a texture coordinate function. Note that the second and third parameters can also be exchanged.<p>
<em>F</em> has to be a point-valued function. The resultant (multi-)vectors may be from any space but must have a point representation in Euclidean space.<p>
<em>C</em> has to be a color-valued function. It gives the color at each point of the surface.<p>
<em>N</em> also has to be point-valued. However, here the point is interpreted as the direction of a normal. These directions need not be normalized, since this is done internally. If no normal function is given, the surface normals are evaluated from the function itself. The normals are used for correct lighting of the surface, as well as drawing the normals if parameter <em>S</em> is given.<p>
<em>T</em> also has to be a point valued function, whereby currently only the first two components of the vectors are used. See <a class="el" href="page_TextureMapping.html">Texture Mapping</a> for more details on texture coordinates. <b>The texture coordinate function always has to be the fourth element in the list <em>A</b></em>. Otherwise it could not be distinguished from the normal function. If you do not to want to specify a normal or color function but you do want to specify a texture function, the color and normal function have to be represented by 0 in the list <em>A</em>. For an example see section <a class="el" href="page_TextureMapping.html#sec_TexMap_ArbSurf">Arbitrary Surfaces</a> of <a class="el" href="page_TextureMapping.html">Texture Mapping</a>.<p>
The lists <em>L1</em> and <em>L2</em> must contain their respective free variable, minimum value, maximum value and number of partitions into which the given range is split.<p>
If the parameter <em>S</em> is given, it sets the length of normals drawn on top of the surface. Negative values are also allowed, in which case the normals are drawn on the back of the surface. If this parameter is not given or set to zero, no normals are drawn.<p>
See section <a class="el" href="page_WorkWithMV.html#sec_Plot">Plotting Vector Functions</a> for more details.<p>
For example, <div class="fragment"><pre class="fragment">        
    :<a class="code" href="group__grp__DrawFunc.html#ga40">Plot</a>([<a class="code" href="group__grp__GAFunc.html#ga36">VecE3</a>(y, x*x*y*y, x),                        <span class="comment">// Function</span>
            <a class="code" href="group__grp__DrawFunc.html#ga2">Color</a>(x*x, y*y, 1-x*x*y*y),                 <span class="comment">// Color</span>
            *(<a class="code" href="group__grp__GAFunc.html#ga36">VecE3</a>(0,2*x*y*y, 1)^<a class="code" href="group__grp__GAFunc.html#ga36">VecE3</a>(1, 2*x*x*y, 0)) <span class="comment">// Normal</span>
           ],
           [x, -1, 1, 20], 
           [y, -1, 1, 20], 
           0.1);
</pre></div><p>
produces the visualization<p>
<div align="center">
<img src="PlotEx3.jpg" alt="PlotEx3.jpg">
</div>
    </td>
  </tr>
</table>
<a class="anchor" name="ga42"></a><!-- doxytag: member="func_Draw.dox::Plot" ref="ga42" args="(list A, list L)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">vertexlist Plot           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">list&nbsp;</td>
          <td class="mdname" nowrap> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>list&nbsp;</td>
          <td class="mdname" nowrap> <em>L</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Draw a point-, circle- or line-valued 1D-function with varying colors. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>A list containing as first element a vector valued function and as second element a color-valued function.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>L</em>&nbsp;</td><td>A list containing free the variable and the plot range.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>This function returns a vertex list containing the evaluated points of the function.</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v2.1</dd></dl>
<em>A</em> has to consist of two elements, a first element <em>F</em> and a second element <em>C</em>. <em>F</em> has to be a point-, circle- or line-valued function. The resultant (multi-)vectors may be from any space but must have a representation in Euclidean space. If <em>F</em> is point-valued, <a class="el" href="group__grp__DrawFunc.html#ga40">Plot()</a> draws a curve in space. If it is circle-valued (e.g. 3-blades in conformal space), then surface spanned by the circles is drawn (see '<code>CanalSurf1.clu</code>' for an example). Similarly, if <em>F</em> is line-valued (e.g. 2-blades in projective space or 3-blades in conformal space), then the surface spanned by the lines is shown.<p>
The second element <em>C</em> has to be a color valued function. It gives the color for each parameter value.<p>
The list <em>L</em> must contain the free variable, the minimum value, the maximum value and the number of partitions into which the given range is split. If the number of partitions is <em>n</em> then <a class="el" href="group__grp__DrawFunc.html#ga40">Plot()</a> evaluates the functions <em>F</em> and <em>C</em>, <em>n+1</em> times. See section <a class="el" href="page_WorkWithMV.html#sec_Plot">Plotting Vector Functions</a> for more details.<p>
For example, <div class="fragment"><pre class="fragment">        
    <a class="code" href="group__grp__VarEnv.html#ga0">_2dView</a> = 1;

    :<a class="code" href="group__grp__DrawFunc.html#ga40">Plot</a>([<a class="code" href="group__grp__GAFunc.html#ga36">VecE3</a>(x, x*x, 0), <a class="code" href="group__grp__DrawFunc.html#ga2">Color</a>(x*x, 0, 1-x*x)],
            [x, -1, 1, 20]);
</pre></div><p>
produces the visualization<p>
<div align="center">
<img src="PlotEx1.jpg" alt="PlotEx1.jpg">
</div>
    </td>
  </tr>
</table>
<a class="anchor" name="ga41"></a><!-- doxytag: member="func_Draw.dox::Plot" ref="ga41" args="(multivector F, list L1, list L2, scalar S)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">vertexlist Plot           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">multivector&nbsp;</td>
          <td class="mdname" nowrap> <em>F</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>list&nbsp;</td>
          <td class="mdname" nowrap> <em>L1</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>list&nbsp;</td>
          <td class="mdname" nowrap> <em>L2</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>S</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Draw a point-valued 2D-function, i.e. a surface. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>F</em>&nbsp;</td><td>A point-valued function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>L1</em>&nbsp;</td><td>A list containing the first free variable and its range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>L2</em>&nbsp;</td><td>A list containing the second free variable and its range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>S</em>&nbsp;</td><td><b>(optional)</b> Length of normals.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>This function returns a vertex list containing the evaluated points of the function.</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v2.1</dd></dl>
<em>F</em> has to be a point-valued function. The resultant (multi-)vectors may be from any space but must have a point representation in Euclidean space.<p>
The lists <em>L1</em> and <em>L2</em> must contain their respective free variable, minimum value, maximum value and number of partitions into which the given range is split.<p>
If the parameter <em>S</em> is given, it sets the length of normals drawn on top of the surface. Negative values are also allowed, in which case the normals are drawn on the back of the surface. If this parameter is not given or set to zero, no normals are drawn.<p>
See section <a class="el" href="page_WorkWithMV.html#sec_Plot">Plotting Vector Functions</a> for more details.<p>
For example, <div class="fragment"><pre class="fragment">        
    :<a class="code" href="group__grp__DrawFunc.html#ga40">Plot</a>(<a class="code" href="group__grp__GAFunc.html#ga36">VecE3</a>(y, x*x*y*y, x),
            [x, -1, 1, 20], 
            [y, -1, 1, 20], 0.1);
</pre></div><p>
produces the visualization<p>
<div align="center">
<img src="PlotEx2.jpg" alt="PlotEx2.jpg">
</div>
    </td>
  </tr>
</table>
<a class="anchor" name="ga40"></a><!-- doxytag: member="func_Draw.dox::Plot" ref="ga40" args="(multivector F, list L)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">vertexlist Plot           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">multivector&nbsp;</td>
          <td class="mdname" nowrap> <em>F</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>list&nbsp;</td>
          <td class="mdname" nowrap> <em>L</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Draw a point-, circle- or line-valued 1D-function. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>F</em>&nbsp;</td><td>A vector valued function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>L</em>&nbsp;</td><td>A list containing free the variable and the plot range.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>This function returns a vertex list containing the evaluated points of the function.</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v1.0</dd></dl>
<code>F</code> has to be a point-, circle- or line-valued function. The resultant (multi-)vectors may be from any space but must have a representation in Euclidean space. If <em>F</em> is point-valued, <a class="el" href="group__grp__DrawFunc.html#ga40">Plot()</a> draws a curve in space. If it is circle-valued (e.g. 3-blades in conformal space), then surface spanned by the circles is drawn (see '<code>CanalSurf1.clu</code>' for an example). Similarly, if <em>F</em> is line-valued (e.g. 2-blades in projective space or 3-blades in conformal space), then the surface spanned by the lines is shown. The circle and line surface functionality is available since version 2.1.<p>
The list <code>L</code> must contain the free variable, the minimum value, the maximum value and the number of partitions into which the given range is split. If the number of partitions is <code>n</code> then <code>Plot</code> evaluates the function <code>F</code> <code>n+1</code> times. See section <a class="el" href="page_WorkWithMV.html#sec_Plot">Plotting Vector Functions</a> for more details.<p>
For example, <div class="fragment"><pre class="fragment">        
    <a class="code" href="group__grp__GAFunc.html#ga7">DefVarsE3</a>();
    
    SQ = <a class="code" href="group__grp__DrawFunc.html#ga40">Plot</a>(x*e1 + x*x*e2, [x, 0, 1, 4]);
    ?SQ;
    :SQ :<a class="code" href="group__grp__ColVars.html#ga1">Red</a>;
</pre></div><p>
produces the output <div class="fragment"><pre class="fragment">    
    SQ = ((0, 0, 0), (0.25, 0.0625, 0), (0.5, 0.25, 0), 
          (0.75, 0.5625, 0), (1, 1, 0))
</pre></div>    </td>
  </tr>
</table>
<a class="anchor" name="ga44"></a><!-- doxytag: member="func_Draw.dox::PopFrame" ref="ga44" args="(void)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void PopFrame           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Restore saved projection matrix from the stack. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v2.0</dd></dl>
This function calls the openGL command <code>glPopMatrix</code>. All parameters corresponding to the frame will be restored. In case of extensive drawing operations it is often more convenient to change the frame and perform the drawings relative to the new origin instead of adjusting all parameters in all drawing functions. Here's an example, <div class="fragment"><pre class="fragment">    
    <a class="code" href="group__grp__DrawFunc.html#ga45">PushFrame</a>();  <span class="comment">// save frame</span>
    <a class="code" href="group__grp__DrawFunc.html#ga64">TranslateFrame</a>(-2,0,0);
    <a class="code" href="group__grp__DrawFunc.html#ga15">DrawCone</a>( <a class="code" href="group__grp__GAFunc.html#ga36">VecE3</a>( 0,0,0), <a class="code" href="group__grp__GAFunc.html#ga36">VecE3</a>( 0,1,0), 1 ); <span class="comment">// Draw cone at current (translated) origin.</span>
    <span class="comment">// more draw operations ....</span>
    <a class="code" href="group__grp__DrawFunc.html#ga44">PopFrame</a>();   <span class="comment">// restore frame</span>
    :e0:<a class="code" href="group__grp__ColVars.html#ga1">Red</a>; <span class="comment">// Visualize origin.</span>
</pre></div> The code will produce the subsequent image.<p>
<div align="center">
<img src="Frame_img1.jpg" alt="Frame_img1.jpg">
</div>
    </td>
  </tr>
</table>
<a class="anchor" name="ga45"></a><!-- doxytag: member="func_Draw.dox::PushFrame" ref="ga45" args="(void)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void PushFrame           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Save current projection matrix to a stack. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v2.0</dd></dl>
This function calls the openGL command <code>glPushMatrix</code>. The matrix that contains the actual settings concerning the frame will be pushed to the stack. To restore the matrix and thus the frame use <code>PopFrame</code>.    </td>
  </tr>
</table>
<a class="anchor" name="ga46"></a><!-- doxytag: member="func_Draw.dox::RotateFrame" ref="ga46" args="(multivector R)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void RotateFrame           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">multivector&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>R</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Rotates the drawing frame. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>R</em>&nbsp;</td><td>An euclidian rotor giving the rotation of the frame.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v1.4</dd></dl>
All drawing operations after a call to this functions are drawn rotated by the given rotor. While the function <a class="el" href="group__grp__DrawFunc.html#ga52">SetFrameRotor()</a> sets the global frame orientation and should only be called once within a script, this function may be called any number of times and only rotated a local frame.    </td>
  </tr>
</table>
<a class="anchor" name="ga47"></a><!-- doxytag: member="func_Draw.dox::RotateView" ref="ga47" args="(multivector R)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void RotateView           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">multivector&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>R</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Rotates the projectview matrix of OpenGl. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>R</em>&nbsp;</td><td>An euclidian rotor giving the rotation of the modelview.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v2.0</dd></dl>
In contrast to the function <code>RotateFrame</code>, the openGL camera coordinate system is rotatad, instead of rotating the object coordinate system. Note that only consecutive drawing commands will relate to the new view of the scene.    </td>
  </tr>
</table>
<a class="anchor" name="ga48"></a><!-- doxytag: member="func_Draw.dox::SetArrowShape" ref="ga48" args="(scalar dLength, scalar dAngle)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SetArrowShape           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>dLength</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>dAngle</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the shape in which arrows are drawn. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dLength</em>&nbsp;</td><td>The length of the arrow tip. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dAngle</em>&nbsp;</td><td>The opening angle of the arrow tip in degrees.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing.</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v2.2</dd></dl>
The initial values are <code>0.15</code> for the length and <code>15</code> for the angle.    </td>
  </tr>
</table>
<a class="anchor" name="ga49"></a><!-- doxytag: member="func_Draw.dox::SetFogColor" ref="ga49" args="(color colFog)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SetFogColor           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">color&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>colFog</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the color of fog. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>colFog</em>&nbsp;</td><td>The fog color.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing.</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v2.2</dd></dl>
You need to enable fog with <a class="el" href="group__grp__DrawFunc.html#ga32">EnableFog()</a> before this has any effect.    </td>
  </tr>
</table>
<a class="anchor" name="ga50"></a><!-- doxytag: member="func_Draw.dox::SetFogDensity" ref="ga50" args="(scalar dDensity)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SetFogDensity           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">scalar&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>dDensity</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the density of fog. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dDensity</em>&nbsp;</td><td>The density. Has to be &gt; 0.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing.</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v2.2</dd></dl>
You need to enable fog with <a class="el" href="group__grp__DrawFunc.html#ga32">EnableFog()</a> before this has any effect.    </td>
  </tr>
</table>
<a class="anchor" name="ga51"></a><!-- doxytag: member="func_Draw.dox::SetFrameOrigin" ref="ga51" args="(scalar x, scalar y, scalar z)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SetFrameOrigin           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>z</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the origin of the drawing frame. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>New x-coordinate of frame origin. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>New y-coordinate of frame origin. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>New z-coordinate of frame origin.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v1.4</dd></dl>
This allows you to set the origin of the basis frame into which all entities are drawn.    </td>
  </tr>
</table>
<a class="anchor" name="ga52"></a><!-- doxytag: member="func_Draw.dox::SetFrameRotor" ref="ga52" args="(multivector R)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SetFrameRotor           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">multivector&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>R</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the rotation of the drawing frame. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>R</em>&nbsp;</td><td>A rotor giving the rotation of the frame.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v1.4</dd></dl>
This allows you to set the orientation of the basis frame into which all entities are drawn.    </td>
  </tr>
</table>
<a class="anchor" name="ga53"></a><!-- doxytag: member="func_Draw.dox::SetLineWidth" ref="ga53" args="(scalar Width)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SetLineWidth           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">scalar&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>Width</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the width of lines in pixel. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Width</em>&nbsp;</td><td>The width of lines in pixels.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v1.4</dd></dl>
The line width set here affects all drawing operations that draw lines. This is, for example, also the case for circles and function plotting.    </td>
  </tr>
</table>
<a class="anchor" name="ga54"></a><!-- doxytag: member="func_Draw.dox::SetMode" ref="ga54" args="(counter mode)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SetMode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">counter&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>mode</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets one or a number of drawing modes. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>The drawing mode.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v1.0</dd></dl>
The modes that are set with this function, influence the visualization of of multivectors. See the <a class="el" href="group__grp__VarAll.html">predefined variable reference</a> for the set of values that can be used with this function.    </td>
  </tr>
</table>
<a class="anchor" name="ga55"></a><!-- doxytag: member="func_Draw.dox::SetPlotMode" ref="ga55" args="(counter mode)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SetPlotMode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">counter&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>mode</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the plot mode for the function <a class="el" href="group__grp__DrawFunc.html#ga40">Plot()</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>The drawing mode.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v1.0</dd></dl>
The modes that are set with this function, influence the way a function is plotted with the function <a class="el" href="group__grp__DrawFunc.html#ga40">Plot()</a>. See the <a class="el" href="group__grp__VarAll.html">predefined variable reference</a> for the set of values that can be used with this function.    </td>
  </tr>
</table>
<a class="anchor" name="ga56"></a><!-- doxytag: member="func_Draw.dox::SetPointSize" ref="ga56" args="(scalar Size)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SetPointSize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">scalar&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>Size</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the size of points in pixel. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Size</em>&nbsp;</td><td>The size of points in pixel.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v1.4</dd></dl>
The point size affects all drawing operations where points are plotted.    </td>
  </tr>
</table>
<a class="anchor" name="ga57"></a><!-- doxytag: member="func_Draw.dox::SetTextSize" ref="ga57" args="(counter Size)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SetTextSize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">counter&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>Size</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the size of text drawn with <a class="el" href="group__grp__DrawFunc.html#ga28">DrawText()</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Size</em>&nbsp;</td><td>The size of the text.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v2.1</dd></dl>
The size variable <em>Size</em> has to be a value between 1 and 7.    </td>
  </tr>
</table>
<a class="anchor" name="ga58"></a><!-- doxytag: member="func_Draw.dox::SetTexture" ref="ga58" args="(image Img)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SetTexture           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">image&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>Img</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the texture for texture mapping, or disables texture mapping. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Img</em>&nbsp;</td><td>(optional) The image to be used for texture mapping.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing.</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v2.2</dd></dl>
See <a class="el" href="page_TextureMapping.html">Texture Mapping</a> for a detailed description.    </td>
  </tr>
</table>
<a class="anchor" name="ga59"></a><!-- doxytag: member="func_Draw.dox::SetTextureRepeat" ref="ga59" args="(scalar dFac)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SetTextureRepeat           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">scalar&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>dFac</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the texture repetition factor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dFac</em>&nbsp;</td><td>The repetition factor.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing.</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v2.2</dd></dl>
See <a class="el" href="page_TextureMapping.html">Texture Mapping</a> for a detailed description.    </td>
  </tr>
</table>
<a class="anchor" name="ga60"></a><!-- doxytag: member="func_Draw.dox::SetViewAngle" ref="ga60" args="(scalar a)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SetViewAngle           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">scalar&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>a</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the perspective angle which affects the modelview. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>A scalar specifying an aperture angle.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v2.0</dd></dl>
This function defines the size of the aperture angle. The value of <em>a</em> must lie between 1 and 179. The default is 70. It can also be regarded as changing the focal length of the (virtual) viewing camera that is used by openGL.    </td>
  </tr>
</table>
<a class="anchor" name="ga61"></a><!-- doxytag: member="func_Draw.dox::SetVisWinSize" ref="ga61" args="(counter iWidth, counter iHeight)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SetVisWinSize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">counter&nbsp;</td>
          <td class="mdname" nowrap> <em>iWidth</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>counter&nbsp;</td>
          <td class="mdname" nowrap> <em>iHeight</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the size of the visualization window. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iWidth</em>&nbsp;</td><td>The new width. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iHeight</em>&nbsp;</td><td>The new height.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing.</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v2.2</dd></dl>
This function sets the width and height of the OpenGL visualization window. This allows you to do screen shots of the visualization of a specific size.    </td>
  </tr>
</table>
<a class="anchor" name="ga62"></a><!-- doxytag: member="func_Draw.dox::StartOverlay" ref="ga62" args="(void)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void StartOverlay           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Starts an overlay block. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v1.4</dd></dl>
This function defines a temporary orthographic projection matrix and a new coordinate system. You can return to the standard coordinate system with the function <a class="el" href="group__grp__DrawFunc.html#ga35">EndOverlay()</a>. The new coordinate system has its origin at the top left of the visualization window. The coordinate at the bottom right is (100, 100). That is, these coordinates can be interpreted as percent of the visualization window. The idea of such an overlay coordinate system is, that it is not changed when the user rotates or translates the standard coordinate system with the mouse. Hence, elements drawn in the overlay appear as if they overlay the standard visualization. This forms the basis for presentations with CLUScript.<p>
Note that the orthographic projection is along the z-axis. This means, that even though an element at different z-depths appears the same, the z-coordinate allows you to define a z-order in which elements are drawn.<p>
Here is an example.<p>
<div class="fragment"><pre class="fragment">    
    <a class="code" href="group__grp__DrawFunc.html#ga62">StartOverlay</a>();

    :<a class="code" href="group__grp__ColVars.html#ga1">Red</a>;
    <a class="code" href="group__grp__DrawFunc.html#ga18">DrawLine</a>(0,0,0, 50,50,0);

    :Green;
    <a class="code" href="group__grp__DrawFunc.html#ga18">DrawLine</a>(100,0,0, 50,50,0);

    :Blue;
    <a class="code" href="group__grp__DrawFunc.html#ga18">DrawLine</a>(50,50,0, 50,100,0);

    <a class="code" href="group__grp__DrawFunc.html#ga35">EndOverlay</a>();
</pre></div><p>
This produces the following visualization.<p>
<div align="center">
<img src="OverlayTest1_img1.jpg" alt="OverlayTest1_img1.jpg">
</div>
<p>
This shows that independent of how the standard visualization basis frame is rotated, the lines in the overlay block are drawn in the same way.    </td>
  </tr>
</table>
<a class="anchor" name="ga63"></a><!-- doxytag: member="func_Draw.dox::StartView" ref="ga63" args="(scalar x, scalar y, scalar w, scalar h)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void StartView           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>h</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Start a new view. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>A scalar defining the x-coordinate of the bottom left corner. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>A scalar defining the y-coordinate of the bottom left corner. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>w</em>&nbsp;</td><td>A scalar defining the width of the view. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>h</em>&nbsp;</td><td>A scalar defining the height of the view.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v2.0</dd></dl>
The two points defined by the four parameters specify a rectangular region within the visualization window. If the values for width and height are in the range [0,1], then they are regarded as percentage values with respect to the size of the whole visualization window. If they are larger than 1, they are regarded as pixel values. The newly created view will then be projected into the defined region. Note that the standard user interaction (mouse mode 0) is restricted to the normal view. But it is possible to adopt the mouse interaction by using other mouse modes. This function starts an environment that has to be ended by the function <a class="el" href="group__grp__DrawFunc.html#ga36">EndView()</a>. Observe that the former view doesn't have any influence on the new view. Here is the example script <code>ExampleScripts/StartView1.clu</code>.<p>
<div class="fragment"><pre class="fragment">    <span class="comment">// Start a view with its bottom-left corner</span>
    <span class="comment">// at the bottom-left corner of the visualization</span>
    <span class="comment">// window, and having half its width and height.</span>
    <a class="code" href="group__grp__DrawFunc.html#ga63">StartView</a>(0,0, 0.5, 0.5);

    <span class="comment">// Start an overlay</span>
    <a class="code" href="group__grp__DrawFunc.html#ga62">StartOverlay</a>();

    <span class="comment">// Draw a rectangle along the </span>
    <span class="comment">// outer border of the view.</span>
    <a class="code" href="group__grp__DrawFunc.html#ga53">SetLineWidth</a>(4);
    :<a class="code" href="group__grp__ColVars.html#ga1">Red</a>;
    <a class="code" href="group__grp__DrawFunc.html#ga18">DrawLine</a>(<a class="code" href="group__grp__GAFunc.html#ga36">VecE3</a>(0,0), <a class="code" href="group__grp__GAFunc.html#ga36">VecE3</a>(100,0));
    <a class="code" href="group__grp__DrawFunc.html#ga18">DrawLine</a>(<a class="code" href="group__grp__GAFunc.html#ga36">VecE3</a>(100,0), <a class="code" href="group__grp__GAFunc.html#ga36">VecE3</a>(100,100));
    <a class="code" href="group__grp__DrawFunc.html#ga18">DrawLine</a>(<a class="code" href="group__grp__GAFunc.html#ga36">VecE3</a>(100,100), <a class="code" href="group__grp__GAFunc.html#ga36">VecE3</a>(0,100));
    <a class="code" href="group__grp__DrawFunc.html#ga18">DrawLine</a>(<a class="code" href="group__grp__GAFunc.html#ga36">VecE3</a>(0,100), <a class="code" href="group__grp__GAFunc.html#ga36">VecE3</a>(0,0));
    <a class="code" href="group__grp__DrawFunc.html#ga53">SetLineWidth</a>(2);

    <span class="comment">// End the overlay</span>
    <a class="code" href="group__grp__DrawFunc.html#ga35">EndOverlay</a>();

    <span class="comment">// Now draw a sphere in the view</span>
    :Blue;
    <a class="code" href="group__grp__DrawFunc.html#ga27">DrawSphere</a>(<a class="code" href="group__grp__GAFunc.html#ga36">VecE3</a>(0,0,0), 1);

    <span class="comment">// End the view</span>
    <a class="code" href="group__grp__DrawFunc.html#ga36">EndView</a>();

    <span class="comment">// Draw the same sphere in the main view</span>
    :Green;
    <a class="code" href="group__grp__DrawFunc.html#ga27">DrawSphere</a>(<a class="code" href="group__grp__GAFunc.html#ga36">VecE3</a>(0,0,0), 1);    
</pre></div><p>
Output:<p>
<div align="center">
<img src="StartView1_1.png" alt="StartView1_1.png">
</div>
    </td>
  </tr>
</table>
<a class="anchor" name="ga65"></a><!-- doxytag: member="func_Draw.dox::TranslateFrame" ref="ga65" args="(multivector T)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void TranslateFrame           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">multivector&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>T</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Translates the drawing frame. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>T</em>&nbsp;</td><td>A multivector representing a vector.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v2.0</dd></dl>
All drawing operations after a call to this functions are drawn translated by the given amount. While the function <a class="el" href="group__grp__DrawFunc.html#ga51">SetFrameOrigin()</a> sets the global frame origin and should only be called once within a script, this function may be called any number of times and only translates a local frame.    </td>
  </tr>
</table>
<a class="anchor" name="ga64"></a><!-- doxytag: member="func_Draw.dox::TranslateFrame" ref="ga64" args="(scalar x, scalar y, scalar z)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void TranslateFrame           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>z</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Translates the drawing frame. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The translation in x-direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>The translation in y-direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>z</em>&nbsp;</td><td>The translation in z-direction.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v1.4</dd></dl>
All drawing operations after a call to this functions are drawn translated by the given amount. While the function <a class="el" href="group__grp__DrawFunc.html#ga51">SetFrameOrigin()</a> sets the global frame origin and should only be called once within a script, this function may be called any number of times and only translates a local frame.    </td>
  </tr>
</table>
<a class="anchor" name="ga67"></a><!-- doxytag: member="func_Draw.dox::TranslateView" ref="ga67" args="(multivector T)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void TranslateView           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">multivector&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>T</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Translate the projectview matrix of OpenGl. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>T</em>&nbsp;</td><td>A multivector representing a vector.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v2.0</dd></dl>
Instead of translating the object coordinate system, the camera is moved. Note that only consecutive drawing commands will relate to the new view of the scene.    </td>
  </tr>
</table>
<a class="anchor" name="ga66"></a><!-- doxytag: member="func_Draw.dox::TranslateView" ref="ga66" args="(scalar x, scalar y, scalar z)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void TranslateView           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scalar&nbsp;</td>
          <td class="mdname" nowrap> <em>z</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Translate the projectview matrix of OpenGl. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The translation in x-direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>The translation in y-direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>z</em>&nbsp;</td><td>The translation in z-direction.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing</dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>v2.0</dd></dl>
Instead of translating the object coordinate system, the camera is moved. Note that only consecutive drawing commands will relate to the new view of the scene.    </td>
  </tr>
</table>
</body></html>
