<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
	<title>CLUCalc: CLUCalc - A Visual Calculator</title>
	<link href="doxygen.css" rel="stylesheet" type="text/css">
	<link href="favicon.ico" rel="SHORTCUT ICON">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1><a class="anchor" name="page_TheLanguage">The Language</a></h1><h2><a class="anchor" name="Contents">
Contents</a></h2>
<ul>
<li>
<a class="el" href="page_TheLanguage.html#subsec_Basics">The Basics</a> </li>
<li>
<a class="el" href="page_TheLanguage.html#subsec_Labels">Labels</a> </li>
<li>
<a class="el" href="page_TheLanguage.html#subsec_Operators">Operators</a> </li>
<li>
<a class="el" href="page_TheLanguage.html#subsec_StructProg">Structured Programming</a> </li>
<li>
<a class="el" href="page_TheLanguage.html#subsec_VarLists">Variable Lists</a> </li>
<li>
<a class="el" href="page_TheLanguage.html#subsec_Strings">Strings</a> </li>
<li>
<a class="el" href="page_TheLanguage.html#subsec_Macros">Macros</a> </li>
</ul>
<p>
<hr>
 <h2><a class="anchor" name="subsec_Basics">
The Basics</a></h2>
The first thing to be said about CLUScript is that it is somewhat similar to the C-programming language. However, the syntax checking is not very strict, such that meaningless scripts may not produce an error message. Given enough time I will try to improve this.<p>
First of all, every line has to be ended by a semicolon. Comments can be included in the script in the same way as in C and C++. For example,<p>
<div class="fragment"><pre class="fragment"><span class="comment">// This is a single line comment</span>
A = 1 + 2;

 This
   is a block
   comment.


?A = A + 1;
</pre></div><p>
The end of a script does not have to be signalled with a particular keyword. By the way, a question mark at the beginning of a line prints the result after evaluation of the corresponding line in the output window. Placing a colon (:) at the beginning of a line draws the result after evaluation of the line in the visualization window, if the result has a geometric interpretation.<p>
In order to execute a script you have to press <b>ctrl + p</b> in CLUCalc. Note that you can simply copy-paste the example given in these help files into the editor window of CLUCalc and then execute them.<p>
<table width="400" bgcolor="#EEEEEE" align="center" border="0" cellspacing="3" cellpadding="3">
<tr>
<td><b>By the way...</b> <br>
 Before a script can be executed it has to be parsed. During parsing a code tree is generated. This code tree may then be executed any number of times. For the user, this two step process is usually hidden. The first time a user executes a script it is parsed. Subsequent executions only execute the code tree. This two-step process has the advantage that a lot of processing only has to be done once. This is particularly important in the present case, since a script may have to be executed many times per second in order to achieve an animated presentation.  </td></tr>
</table>
<p>
<hr>
 <h2><a class="anchor" name="subsec_Labels">
Labels</a></h2>
A label can be two things: either it represents a variable that stands for some value, or it refers to a function. Anything that starts with any of the following characters is interpreted as a label.<p>
<div class="fragment"><pre class="fragment">_abcdefghijklmnopqrstuvwxyzäöüß
ABCDEFGHIJKLMNOPQRSTUVWXYZÄÖÜ
</pre></div><p>
A label may also include the characters 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, but these must not be the first character of a label. For example, "A1" is a label but "1A" is interpreted as the number 1 followed by label "A". The parser does not recognize the latter case as an error. The "Umlaute" ä, ö, ü and ß are also valid letters in a label, which allows you to use any German word as a label.<p>
Variables do not have to be declared explicitly. Instead, when the parser encounters an unknown label, it assumes it to be a variable of type "counter", i.e. an integer, and initializes it with zero.<p>
The type of a variable is automatically changed appropriately when it is assigned a particular value. For example,<p>
<div class="fragment"><pre class="fragment">A = 1.2;
<span class="comment">// Now A is of type 'Scalar'</span>

A = <a class="code" href="group__grp__GAFunc.html#ga36">VecE3</a>(1, 1, 1);
<span class="comment">// Now A is of type 'Multivector'</span>

A = <span class="stringliteral">"Hello World"</span>;
<span class="comment">// Now A is of type 'String'</span>
</pre></div><p>
Variables can be of the following types: <ul>
<li>
<code>counter</code>. This is equivalent to an integer variable. A corresponding variable is created by assigning a label a whole number not followed by a '.', eg. <code>A = 2</code>.<p>
</li>
<li>
<code>scalar</code>. This is equivalent to a double variable. You can create a variable of this type by writing for example, <code>A = 3.1415</code>, or <code>A = 31415e-4</code>. Counter variables are automatically casted into Scalar variables if needed. However, the reverse is only possible if the value of a Scalar variable is equal to an integer value.<p>
</li>
<li>
<code>multivector</code>. Multivectors can be created using the functions <code>VecE3</code>, <code>VecP3</code> and <code>VecN3</code>, which create multivectors of grade 1 (ie. vectors) in Euclidean, projective and conformal space, respectively. Note that you cannot apply operators to multivectors from different spaces. Nevertheless, you can use the above mentioned functions to convert multivectors from one space into another. For example,<p>
<div class="fragment"><pre class="fragment">A = <a class="code" href="group__grp__GAFunc.html#ga36">VecE3</a>(1, 1, 1); 
PA = <a class="code" href="group__grp__GAFunc.html#ga42">VecP3</a>(A);
</pre></div> embeds vector <img class="formulaInl" alt="$ A = e_1+e_2+e_3 $" src="form_117.png"> in projective space.<p>
</li>
<li>
<code>matrix</code>. Matrices can be created using the function <code>Matrix</code>. This will be discussed later on.<p>
</li>
<li>
<code>string</code>. Strings are created by enclosing an arbitrary text in double quotes, e.g. <code>A = "Hello World";</code>. Strings can be concatenated with the '+' operator. You can also add variables of any type to a string, which converts the variable into a string and then concatenates the strings. For example,<p>
<div class="fragment"><pre class="fragment">A = 1.2; 
Text = <span class="stringliteral">"The result is: "</span> + A;
</pre></div><p>
Now the variable <code>Text</code> contains the string "The result is: 1.2". You can include the symbol " in a string by writing \", eg.<p>
<div class="fragment"><pre class="fragment">Text = <span class="stringliteral">"This is \"Text\"."</span>
</pre></div><p>
</li>
<li>
<code>color</code>. There exist a number of predefined color variables like <code>Red, Green, Blue, Magenta, Cyan, Yellow, Black, White</code>, etc. If you want to define your own color, use the function <code>Color</code>.<p>
</li>
<li>
<code>list</code>. A variable of this type contains a list of variables. These may be of different types. Nested lists are also allowed up to a level where your computer runs out of memory or processing power ;-).<p>
</li>
<li>
<code>vertexlist</code>. A variable of this type contains a list of vertices. Vertices are simply 3D-points which are used for drawing objects. A vertex list is returned by the <code>Plot</code> function. In order to draw a vertex list use the colon operator.<p>
</li>
<li>
<code>image</code>. A variable of this type contains an image. This will be discussed in an extra section. </li>
</ul>
<p>
Internally, the variables that are created in a script are saved in a list. This list of variables is only deleted every time the script is parsed. The variable list is not reset before every execution of the code-tree. Therefore, variables that are assigned a value during the first execution of a script, already contain this value at the beginning of the second execution of the script.<p>
For example, you can count the number of times a script was executed by writing <div class="fragment"><pre class="fragment">?A = A + 1;
</pre></div> somewhere in the script.<h3><a class="anchor" name="subsubsec_ReferenceOp">
The Reference Operator</a></h3>
The assignment operator &lt;tt&gt;= copies the value given on its RHS into the variable given on the LHS. As will be seen in later sections, it is not always desirable to copy the content of a variable. Sometimes a reference to a variable saves some writing and is sufficient. References can only be created to variables and not to constant objects. A reference to a variable is creates with the operator &lt;tt&gt;-&gt;. For example,<p>
<div class="fragment"><pre class="fragment">?a = 1;
?b -&gt; a;
b = 2;
?a;
</pre></div><p>
has the output<p>
<div class="fragment"><pre class="fragment">a = 1
b -&gt; 1
a = 2
</pre></div><p>
In this code snippet a variable <code>a</code> is created and assigned the value <code>1</code>. Then a variable <code>b</code> is assigned a reference to variable <code>a</code>. Now, when <code>b</code> is changed then so is <code>a</code>, as can be seen in the next to code lines. If a reference is made to a constant object, then the reference operator is equivalent to the assignment operator. For example,<p>
<div class="fragment"><pre class="fragment">?b -&gt; 2;
</pre></div><p>
results in<p>
<div class="fragment"><pre class="fragment">b = 2
</pre></div><p>
Furthermore, when the reference operator is applied to a reference variable, no reference to the reference is created. Instead, the reference on the RHS is simply assigned to the LHS. For example,<p>
<div class="fragment"><pre class="fragment">?a = 1;     <span class="comment">// Initialize a with 1</span>
?b -&gt; a;    <span class="comment">// Assign b the reference to a </span>
?c -&gt; b;    <span class="comment">// Also assigns c the reference to a (not b)</span>
?b -&gt; 0;    <span class="comment">// Sets b to 0 without changing a (or c)</span>

?a = 2;     <span class="comment">// Set a to 2</span>
?c;         <span class="comment">// Now c also returns the value of a</span>
</pre></div><p>
has output<p>
<div class="fragment"><pre class="fragment">a = 1
b -&gt; 1
c -&gt; 1
b = 0
a = 2
c -&gt; 2
</pre></div><p>
<hr>
 <h2><a class="anchor" name="subsec_Operators">
Operators</a></h2>
In CLUScript operators can either be right-sided unary or binary. For example, in <code>-1.2</code> the minus operator is a unary operator acting on the element on its right, whereas in <code>2 - 1.2</code> the minus operator is binary. Every operator also has a certain "binding strength". An operator with a higher binding strength is executed before an operator with a lower one. In the following the various operators are described.<p>
<dl compact><dt><b>Attention:</b></dt><dd>Note that variables of type Multivector which only consist of a scalar part are automatically interpreted as Scalars if necessary.</dd></dl>
<table width="400" bgcolor="#EEEEEE" align="center" border="0" cellspacing="3" cellpadding="3">
<tr>
<td><b>By the way...</b> <br>
 ... all operators apart from the assignment operator (<code>=</code>) and the print operator (<code>?</code>) are recursively applied to list. See section <a class="el" href="page_TheLanguage.html#subsec_VarLists">Variable Lists</a> for more information on that. </td></tr>
</table>
<p>
<b>Point Operators</b>. Many of the operators described in the following also have a 'point' version. For example, there exists the operator &lt;tt&gt;+ but also <code>.+</code>. These 'point' versions of the operators perform the same operation as the operators without the leading point (pointless operators ;-). However, when point operators are applied between two lists (see section <a class="el" href="page_TheLanguage.html#subsec_VarLists">Variable Lists</a>) or matrices (see <a class="el" href="page_WorkWithMat.html">Working with Matrices</a>), then the base operator version is applied between each pair of elements separately. If an operator has a point version, this is noted in the following lists.<p>
The available binary operators are the following:<p>
<table align="center" border="1" bgcolor="#EEEEEE" cellspacing="3" cellpadding="3">
<tr>
<td>Operator </td><td>Function </td><td>LHS-Type </td><td>RHS-Type </td><td>L to R  </td></tr>
<tr bgcolor="#F1F1F1">
<td><code>*</code>, <code>.*</code>  </td><td>(geometric) product  </td><td>Multivector  </td><td>Multivector  </td><td>yes   </td></tr>
<tr>
<td></td><td></td><td>Multivector  </td><td>Scalar  </td><td>yes  </td></tr>
<tr>
<td></td><td></td><td>Scalar  </td><td>Scalar  </td><td>yes  </td></tr>
<tr>
<td></td><td>matrix product  </td><td>Matrix  </td><td>Matrix  </td><td>yes  </td></tr>
<tr>
<td></td><td></td><td>Matrix  </td><td>Scalar  </td><td>yes <p>
</td></tr>
<tr bgcolor="#F1F1F1">
<td><code>/</code>, <code>./</code>  </td><td>(geometric) division  </td><td>Multivector  </td><td>Multivector  </td><td>yes  </td></tr>
<tr>
<td></td><td></td><td>Multivector  </td><td>Scalar  </td><td>yes  </td></tr>
<tr>
<td></td><td></td><td>Scalar  </td><td>Scalar  </td><td>yes  </td></tr>
<tr>
<td></td><td>matrix division  </td><td>Matrix  </td><td>Matrix  </td><td>yes  </td></tr>
<tr>
<td></td><td></td><td>Matrix  </td><td>Scalar  </td><td>yes <p>
</td></tr>
<tr bgcolor="#F1F1F1">
<td><code>.</code>, <code>..</code>  </td><td>inner product  </td><td>Multivector  </td><td>Multivector  </td><td>yes <p>
</td></tr>
<tr bgcolor="#F1F1F1">
<td><code>^</code>, <code>.^</code>  </td><td>outer product  </td><td>Multivector  </td><td>Multivector  </td><td>yes  </td></tr>
<tr>
<td></td><td></td><td>Multivector  </td><td>Scalar  </td><td>yes <p>
</td></tr>
<tr bgcolor="#F1F1F1">
<td><code>^^</code>  </td><td>power  </td><td>Scalar  </td><td>Scalar  </td><td>yes  </td></tr>
<tr>
<td></td><td></td><td>Multivector  </td><td>Counter  </td><td>yes <p>
</td></tr>
<tr bgcolor="#F1F1F1">
<td><code>+</code>, <code>.+</code>  </td><td>addition  </td><td>Multivector  </td><td>Multivector  </td><td>yes  </td></tr>
<tr>
<td></td><td></td><td>Matrix  </td><td>Matrix  </td><td>yes  </td></tr>
<tr>
<td></td><td></td><td>Scalar  </td><td>Scalar  </td><td>yes  </td></tr>
<tr>
<td></td><td>concatenation  </td><td>String  </td><td>all types  </td><td>yes <p>
</td></tr>
<tr bgcolor="#F1F1F1">
<td><code>-</code>, <code>.-</code>  </td><td>subtraction  </td><td>Multivector  </td><td>Multivector  </td><td>yes  </td></tr>
<tr>
<td></td><td></td><td>Matrix  </td><td>Matrix  </td><td>yes  </td></tr>
<tr>
<td></td><td></td><td>Scalar  </td><td>Scalar  </td><td>yes <p>
</td></tr>
<tr bgcolor="#F1F1F1">
<td><code>|</code>  </td><td>join  </td><td>Multivector  </td><td>Multivector  </td><td>yes  </td></tr>
<tr>
<td></td><td>OR  </td><td>Counter  </td><td>Counter  </td><td>yes <p>
</td></tr>
<tr bgcolor="#F1F1F1">
<td><code>&amp;</code> </td><td>meet  </td><td>Multivector  </td><td>Multivector  </td><td>yes  </td></tr>
<tr>
<td></td><td>AND  </td><td>Counter  </td><td>Counter  </td><td>yes <p>
</td></tr>
<tr bgcolor="#F1F1F1">
<td><code>%</code> </td><td>modulo  </td><td>Scalar  </td><td>Scalar  </td><td>yes <p>
</td></tr>
<tr bgcolor="#F1F1F1">
<td><code>°</code>  </td><td>grade projection  </td><td>Multivector  </td><td>Counter  </td><td>no <p>
</td></tr>
<tr bgcolor="#F1F1F1">
<td><code>~</code>  </td><td>index list generation  </td><td>Counter  </td><td>Counter  </td><td>yes <p>
</td></tr>
<tr bgcolor="#F1F1F1">
<td><code>&lt;&lt; </code>, <code>.&lt;&lt; </code>  </td><td>list element concatenation  </td><td>list  </td><td>any type  </td><td>no  </td></tr>
<tr>
<td></td><td>string concatenation  </td><td>string  </td><td>any type  </td><td>no  </td></tr>
</table>
<p>
<dl compact><dt><b>Attention:</b></dt><dd>The operator &lt;code&gt;# does no longer exist in CLUScript version 2.0.</dd></dl>
If there is a "yes" in the column "L to R" then the LHS and RHS variable types can be exchanged. For example, the second row in the table means that you can write <code>VecE3(1,2,3) * 1.2</code> but also <code>1.2 * VecE3(1,2,3)</code>. Since a variable of type Counter can always be casted to a variable of type Scalar, you can also use a Counter variable wherever you see the type Scalar in the table.<p>
The unary operators available in CLUScript are:<p>
<table align="center" border="1" bgcolor="#EEEEEE" cellspacing="3" cellpadding="3">
<tr>
<td>Operator  </td><td>Function  </td><td>Variable Types   </td></tr>
<tr bgcolor="#F1F1F1">
<td>? </td><td>print element </td><td>all types  </td></tr>
<tr bgcolor="#F1F1F1">
<td>: </td><td>draw element </td><td>Multivector, Matrix  </td></tr>
<tr bgcolor="#F1F1F1">
<td>! </td><td>inverse </td><td>Multivector, Matrix, Scalar  </td></tr>
<tr bgcolor="#F1F1F1">
<td>* </td><td>dual </td><td>Multivector <p>
</td></tr>
<tr bgcolor="#F1F1F1">
<td><code>~</code> </td><td>reverse </td><td>Multivector  </td></tr>
<tr>
<td></td><td>transpose </td><td>Matrix <p>
</td></tr>
<tr bgcolor="#F1F1F1">
<td><code>'</code> </td><td>main involution </td><td>Multivector <p>
</td></tr>
<tr bgcolor="#F1F1F1">
<td><code>-</code> </td><td>negate </td><td>Counter, Scalar  </td></tr>
<tr>
<td></td><td></td><td>Multivector, Matrix  </td></tr>
</table>
<p>
Here is a list of all binary logical operators. The return type is either a scalar set to zero or unity, depending on whether the result of the logical operation if false or true. Operations between matrices and single elements or lists and single elements return a matrix or a list, respectively. These matrices or lists then contain only zero and unity entries, depending on the result of the logical operation. Note that for all logical operations the LHS and RHS may be exchanged.<p>
<table align="center" border="1" bgcolor="#EEEEEE" cellspacing="3" cellpadding="3">
<tr>
<td>Symbol  </td><td>Meaning  </td><td>LHS Type  </td><td>RHS Type  </td><td>Return Type   </td></tr>
<tr bgcolor="#F1F1F1">
<td><code>==</code>, <code>.==</code>  </td><td>equality  </td><td>scalar  </td><td>scalar  </td><td>scalar   </td></tr>
<tr>
<td></td><td></td><td>matrix  </td><td>matrix  </td><td>scalar   </td></tr>
<tr>
<td></td><td></td><td>matrix  </td><td>scalar  </td><td>matrix   </td></tr>
<tr>
<td></td><td></td><td>multivector  </td><td>multivector  </td><td>scalar   </td></tr>
<tr>
<td></td><td></td><td>string  </td><td>string  </td><td>scalar   </td></tr>
<tr>
<td></td><td></td><td>image  </td><td>color  </td><td>image  <p>
</td></tr>
<tr bgcolor="#F1F1F1">
<td><code>!=</code>, <code>.!=</code>  </td><td>inequality  </td><td>scalar  </td><td>scalar  </td><td>scalar   </td></tr>
<tr>
<td></td><td></td><td>matrix  </td><td>matrix  </td><td>scalar   </td></tr>
<tr>
<td></td><td></td><td>matrix  </td><td>scalar  </td><td>matrix   </td></tr>
<tr>
<td></td><td></td><td>multivector  </td><td>multivector  </td><td>scalar   </td></tr>
<tr>
<td></td><td></td><td>string  </td><td>string  </td><td>scalar   </td></tr>
<tr>
<td></td><td></td><td>image  </td><td>color  </td><td>image  <p>
</td></tr>
<tr bgcolor="#F1F1F1">
<td><code>&gt;</code>, <code>.&gt;</code>  </td><td>greater than  </td><td>scalar  </td><td>scalar  </td><td>scalar   </td></tr>
<tr>
<td></td><td></td><td>matrix  </td><td>scalar  </td><td>matrix  <p>
</td></tr>
<tr bgcolor="#F1F1F1">
<td><code>&lt; </code>, <code>.&lt; </code>  </td><td>smaller than  </td><td>scalar  </td><td>scalar  </td><td>scalar   </td></tr>
<tr>
<td></td><td></td><td>matrix  </td><td>scalar  </td><td>matrix  <p>
</td></tr>
<tr bgcolor="#F1F1F1">
<td><code>&gt;=</code>, <code>.&gt;= </code>  </td><td>greater or equal than  </td><td>scalar  </td><td>scalar  </td><td>scalar   </td></tr>
<tr>
<td></td><td></td><td>matrix  </td><td>scalar  </td><td>matrix  <p>
</td></tr>
<tr bgcolor="#F1F1F1">
<td><code>&lt;=</code>, <code>.&lt;= </code>  </td><td>smaller or equal than  </td><td>scalar  </td><td>scalar  </td><td>scalar   </td></tr>
<tr>
<td></td><td></td><td>matrix  </td><td>scalar  </td><td>matrix  <p>
</td></tr>
<tr bgcolor="#F1F1F1">
<td><code>&amp;&amp;</code>, <code>.&amp;&amp;</code>  </td><td>logical AND  </td><td>scalar  </td><td>scalar  </td><td>scalar   </td></tr>
<tr>
<td></td><td></td><td>matrix  </td><td>scalar  </td><td>matrix  <p>
</td></tr>
<tr bgcolor="#F1F1F1">
<td><code>||</code>, <code>.||</code>  </td><td>logical OR  </td><td>scalar  </td><td>scalar  </td><td>scalar   </td></tr>
<tr>
<td></td><td></td><td>matrix  </td><td>scalar  </td><td>matrix  <p>
</td></tr>
</table>
<p>
There is only one logical unary operator. <table align="center" border="1" bgcolor="#EEEEEE" cellspacing="3" cellpadding="3">
<tr>
<td>Symbol  </td><td>Meaning  </td><td>RHS Type  </td><td>Return Type   </td></tr>
<tr bgcolor="#F1F1F1">
<td><code>!!</code>  </td><td>logical NOT  </td><td>scalar  </td><td>scalar   </td></tr>
<tr>
<td></td><td></td><td>matrix  </td><td>matrix   </td></tr>
</table>
<p>
The binding strengths of the various operators are listed in the following table from strongest to weakest binding operator.<p>
<table align="center" border="1" bgcolor="#EEEEEE" cellspacing="3" cellpadding="3">
<tr>
<td>Operator(s) </td><td>Direction  </td></tr>
<tr>
<td>Functions </td><td>RL  </td></tr>
<tr>
<td><code>°</code> (grade proj.)  </td><td>LR   </td></tr>
<tr>
<td><code>*</code> (dual), <code>-</code> (negate), <code>!</code>, <code>~</code>, <code>'</code>  </td><td>RL   </td></tr>
<tr>
<td><code>%</code> (modulo)  </td><td>LR   </td></tr>
<tr>
<td><code>^</code> (outer product)  </td><td>LR   </td></tr>
<tr>
<td><code>.</code> (inner product)  </td><td>LR   </td></tr>
<tr>
<td><code>*</code> (geometric product), <code>/</code> </td><td>LR   </td></tr>
<tr>
<td><code>|</code> (join), <code>&amp;</code> (meet)  </td><td>LR   </td></tr>
<tr>
<td><code>-</code>  </td><td>LR   </td></tr>
<tr>
<td><code>+</code>  </td><td>LR  <p>
</td></tr>
<tr>
<td><code>~</code> (index list) </td><td>RL  <p>
</td></tr>
<tr>
<td><code>==</code> (equal), <code>!=</code> (not equal), <br>
 <code>&lt; </code>, <code>&gt; </code>, <br>
 <code>&lt;= </code>, <code>&gt;= </code>, <br>
  </td><td>LR  <p>
</td></tr>
<tr>
<td><code>!! (NOT)</code>  </td><td>LR  <p>
</td></tr>
<tr>
<td><code>&amp;&amp; (AND)</code>  </td><td>LR  <p>
</td></tr>
<tr>
<td><code>|| (OR)</code>  </td><td>LR  <p>
</td></tr>
<tr>
<td><code>&lt;&lt; (list concatenation)</code>  </td><td>LR  <p>
</td></tr>
<tr>
<td><code>=</code>  </td><td>RL   </td></tr>
<tr>
<td><code>:</code> (draw), <code>?</code> (print)  </td><td>RL   </td></tr>
</table>
<p>
If a number of operators appear on the same line, they bind equally strong. In the case that a number of equally strong operators are to be executed sequentially, the second column indicates whether this is done from right to left (RL) or from left to right (LR). For example, the expression <code>A * B * C</code> is equivalent to <code>(A * B) * C</code>. That is, the <code>*</code> operator is executed from left to right. The <code>=</code> operator on the other hand is executed from right to left, i.e. <code>A = B = C</code> is equivalent to <code>A = (B = C)</code>.<p>
Most operators return a temporary variable containing the result of the operation. These temporary variables are constants and cannot be assigned any value. That is, <code>A * B = C</code> is not allowed. The assignment operator &lt;tt&gt;= returns the value of the LHS variable. Therefore, it is possible to write <code>A = B = 1</code>, which first assigns <code>1</code> to <code>B</code> and then to <code>A</code>.<p>
The print operator &lt;tt&gt;? and the draw operator &lt;tt&gt;: both return no value at all. Therefore, you can write <code>:VecE3(1,1,1):Red</code> in order to first set the drawing color to red and then to draw the vector. Similarly, <code>?A ?1.2</code> first prints <code>1.2</code> and then the value of <code>A</code>.<p>
<table width="400" bgcolor="#EEEEEE" align="center" border="0" cellspacing="3" cellpadding="3">
<tr>
<td><b>By the way...</b> <br>
 ... if you write <code>?A = 1.2</code> the output is <code>A = 1.2</code>, and <code>?1.2</code> produces the output <code>Constant = 1.2</code>. In order to obtain an output like <code>The result is 1.2!</code>, you need to write <code>?"The result is " + 1.2 + "!"</code>. </td></tr>
</table>
<p>
<hr>
<h2><a class="anchor" name="subsec_StructProg">
Structured Programming</a></h2>
With CLUScript v1.4 structured programming was introduced. That is, there exist conditional branching and loops.<p>
The syntax of if-clauses is just the same as in C/C++. <div class="fragment"><pre class="fragment"><span class="keywordflow">if</span> ([condition1])
{
    [condition1 <span class="keyword">true</span> branch]
}
<span class="keywordflow">else</span> <span class="keywordflow">if</span> ([condition2])
{
    [condition2 <span class="keyword">true</span> branch]
}
<span class="keywordflow">else</span>
{
    [<span class="keyword">false</span> branch]
}
</pre></div><p>
You do not need the curly brackets, if you only want to execute a single line. For example, <div class="fragment"><pre class="fragment"><span class="keywordflow">if</span> (a == 1)
    ?<span class="stringliteral">"'a' is equal to one"</span>;
<span class="keywordflow">else</span>
    ?<span class="stringliteral">"'a' is not equal to one"</span>;
</pre></div><p>
The condition in <code>if ([condition])</code> must be an expression that results in a scalar. If this scalar is zero, then the condition is considered false, otherwise it is considered true. The logical operators like '<code>==</code>' return either one or zero.<p>
The other important functionality apart from conditional branching, is that of loops, i.e. executing a certain part of code a number of times. In CLUScript the different loops like <code>for</code>-loops, <code>do-while</code>-loops and <code>while</code>-loops are unified in a more simple syntax. The keyword <code>loop</code> asks the parser to continually execute the next line or block of code following the keyword. This is done until the keyword <code>break</code> is encountered. A standard <code>for</code>-loop may then be implemented as follows.<p>
<div class="fragment"><pre class="fragment"><span class="comment">// A for-loop executed 5 times</span>

<span class="comment">// Reset the counter variable</span>
i = 0;
loop
{
    <span class="comment">// Check whether five counts</span>
    <span class="comment">// have already been achieved.</span>
    <span class="keywordflow">if</span> (i &gt;= 5)
        <span class="comment">// If we are finished end the loop</span>
        <span class="keywordflow">break</span>;

    <span class="comment">// Do something sensible</span>
    
    <span class="comment">// Increment the counter</span>
    i = i + 1;
}
</pre></div><p>
If you forget to add a <code>break</code> command, or never allow your code to reach a <code>break</code> command, the loop would in principle run indefinitely. In order to avoid your programs to hang, CLUCalc has a maximum count of 10000 for loops after which the loops is exited in any case. A better solution to the problem would be to run the parser in an extra thread, but again this is something for a future version of CLUCalc.<p>
<hr>
 <h2><a class="anchor" name="subsec_VarLists">
Variable Lists</a></h2>
<dl compact><dt><b>Attention:</b></dt><dd>From CLUScript v2.0 onwards <b>lists are defined through square brackets</b> and not with round brackets as before. Lists of a single element are also not interpreted as the element itself, as was the case before.</dd></dl>
Variable lists are quite useful tools. A variable list is a comma separated list of elements enclosed in <b>square</b> brackets. For example, <code>[A, 1.2, Red]</code> is a list containing the label <code>A</code>, the Scalar <img class="formulaInl" alt="$1.2$" src="form_118.png"> and the color <code>Red</code>. You can also nest lists to any level, as in <code>[A, [B, C]]</code>.<p>
There are a number of different was of generating lists. The most obvious one is to write <code>A = [1,2,3]</code> to assign <code>A</code> the list <code>[1,2,3]</code>. Another method is to use the concatenation operator &lt;tt&gt;&lt;&lt;  as in the following example.<p>
<div class="fragment"><pre class="fragment">    A = []; <span class="comment">// Create an empty list</span>
    A &lt;&lt; 1;
    A &lt;&lt; 2 &lt;&lt; 3;
</pre></div><p>
Now <code>A</code> also contains <code>[1,2,3]</code>. If it is known beforehand how many elements a list will have, but their entries can only be evaluated at a later stage, it is faster to create a list of the appropriate size and then set the components, instead of using the concatenation operator. This can be done with the function <a class="el" href="group__grp__List.html#ga3">List()</a>. For example,<p>
<div class="fragment"><pre class="fragment">    A = <a class="code" href="group__grp__List.html#ga3">List</a>(3);
    A(1) = 1;
    A(2) = 2;
    A(3) = 3;
</pre></div><p>
again generates the same list as before. From CLUScript v2.2 onwards, <b>it is possible to assign to lists of variables</b>. For example, if you want to assign the values 1, 2 and 3 to variables A, B and C, you can write<p>
<div class="fragment"><pre class="fragment">    [A,B,C] = [1,2,3];
</pre></div><p>
This is particularly useful when dealing with functions that return a list of values, as for example the function <a class="el" href="group__grp__Matrix.html#ga33">SVD()</a>, which evaluates the singular value decomposition of a matrix. It return a list of three matrices, typically called U, D and V. To have direct access to these matrices you can write<p>
<div class="fragment"><pre class="fragment">    [U,D,V] = <a class="code" href="group__grp__Matrix.html#ga33">SVD</a>(M);
</pre></div><h3><a class="anchor" name="subsubsec_OpRecurseOnLists">
Recursive Operators</a></h3>
You can assign variable lists to variables, as in <code>A = [1, 2, 3]</code>. This is useful since most operators are applied recursively to variable lists. The only operators that are not are <code>=</code>. For example, <code>[1, 2, 3] + 1</code> is equivalent to writing <code>[1+1, 2+1, 3+1]</code>. Furthermore, operating with lists on lists applies the corresponding operator for every element of one list to every element of the other list, creating a nested list in the process. For example, <code>[A, B] * [C, D]</code> is equivalent to <code>[ [A*C, B*C], [A*D, B*D] ]</code>. This last expression is basically a <img class="formulaInl" alt="$2\times 2$" src="form_119.png"> matrix. And yes, you can convert such a nested list into a variable of type 'matrix' using the function <a class="el" href="group__grp__Matrix.html#ga19">Matrix()</a>.<p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__grp__List.html#ga3">List</a> = [1, 2] + [1, 2];
M = <a class="code" href="group__grp__Matrix.html#ga19">Matrix</a>(<a class="code" href="group__grp__List.html#ga3">List</a>);
</pre></div><p>
After these two lines <code>M</code> contains the matrix <p class="formulaDsp">
<img class="formulaDsp" alt="\[ M = \left(\begin{array}{cc} 2 &amp; 3 \\ 3 &amp; 4 \end{array}\right) \]" src="form_120.png">
<p>
<h3><a class="anchor" name="subsubsec_PointOperators">
Point Operators</a></h3>
In section <a class="el" href="page_TheLanguage.html#subsec_Operators">Operators</a> point operators were already mentioned. Here we will look at their properties in some more detail. In the previous section it was shown that an operator applied between two lists results in a recursive application of the operator on the elements of the lists. This behaviour is not always desirable. For example, suppose you have two lists <code>L1 = [1,2,3]</code> and <code>L2 = [1,0,-1]</code> and you would like to add these two lists elementwise. That is, add the first element of <code>L1</code> to the first element of <code>L2</code>, etc. This can be achieved with the operator &lt;tt&gt;.+. Here is an example,<p>
<div class="fragment"><pre class="fragment">?L1 = [1,2,3];
?L2 = [1,0,-1];
?Sum = L1 + L2;
?PointSum = L1 .+ L2;
</pre></div><p>
has the output<p>
<div class="fragment"><pre class="fragment">L1 = [1, 2, 3]
L2 = [1, 0, -1]
Sum = [[2, 1, 0], [3, 2, 1], [4, 3, 2]]
PointSum = [2, 2, 2]
</pre></div><p>
That is, the point summation is somewhat like vector addition, if you interpret the lists <code>L1</code> and <code>L2</code> as vectors. Note that the standard operator <code>+</code> is applied between the elements of the lists. Therefore, this works for lists containing any elements for which the operator <code>+</code> is defined. An example is,<p>
<div class="fragment"><pre class="fragment">?[<span class="stringliteral">"Hello "</span>, 2] + [<span class="stringliteral">"World"</span>, <span class="stringliteral">" times"</span>];
?[<span class="stringliteral">"Hello "</span>, 2] .+ [<span class="stringliteral">"World"</span>, <span class="stringliteral">" times"</span>];
</pre></div><p>
results in<p>
<div class="fragment"><pre class="fragment">Constant = [[Hello World, Hello  times], [2World, 2 times]]
Constant = [Hello World, 2 times]
</pre></div><p>
This behaviour is the same for all point operators. However, we should probably say something about the list concatenation operator &lt;tt&gt;&lt;&lt;  and its point version <code>.&lt;&lt; <code>. The operator &lt;tt&gt;&lt;&lt;<code> concatenates the element on its left to the list on its right. For example,</code></code></code><p>
<code><code><code><div class="fragment"><pre class="fragment">?L = [1,2,3];
L &lt;&lt; 4;
?L;
</pre></div></code></code></code><p>
<code><code><code>gives</code></code></code><p>
<code><code><code><div class="fragment"><pre class="fragment">L = [1, 2, 3]
L = [1, 2, 3, 4]
</pre></div></code></code></code><p>
<code><code><code>This also works for lists on the RHS.</code></code></code><p>
<code><code><code><div class="fragment"><pre class="fragment">?L = [1,2,3];
L &lt;&lt; [4,5];
?L
L &lt;&lt; [[6,7], <span class="stringliteral">"Hello"</span>];
?L;
</pre></div></code></code></code><p>
<code><code><code>which gives</code></code></code><p>
<code><code><code><div class="fragment"><pre class="fragment">L = [1, 2, 3]
L = [1, 2, 3, 4, 5]
L = [1, 2, 3, 4, 5, [6, 7], Hello]
</pre></div></code></code></code><p>
<code><code><code>The point version of this operator concatenates element wise if both lists have the same number of elements and if the elements are lists themselves. For example,</code></code></code><p>
<code><code><code><div class="fragment"><pre class="fragment">?L1 = [1, 2, 3];
?L2 = [4, 5, 6];
?L12 = L1 .&lt;&lt; L2;
</pre></div></code></code></code><p>
<code><code><code>gives</code></code></code><p>
<code><code><code><div class="fragment"><pre class="fragment">L1 = [1, 2, 3]
L2 = [4, 5, 6]
L12 = [1, 2, 3, 4, 5, 6]
</pre></div></code></code></code><p>
<code><code><code>whereas</code></code></code><p>
<code><code><code><div class="fragment"><pre class="fragment">?L1 = [[1], [2], [3]];
?L2 = [[4], [5], [6]];
?L12 = L1 .&lt;&lt; L2;
</pre></div></code></code></code><p>
<code><code><code>gives</code></code></code><p>
<code><code><code><div class="fragment"><pre class="fragment">L1 = [[1], [2], [3]]
L2 = [[4], [5], [6]]
L12 = [[1, 4], [2, 5], [3, 6]]
</pre></div></code></code></code><p>
<code><code><code></code></code></code><h3><a class="anchor" name="subsubsec_ListElementSelection">
Element Selection</a></h3>
<code><code><code> <a class="anchor" name="Manual_Op_Selection"></a> Elements of variable lists, vertex lists, matrices and images can be retrieved using the round brackets '<code>()</code>' as in a function call. Applied to a list as in <code>[1,2](2)</code>, the operator returns the second element in the list. Applied to a nested list it returns the appropriate sublist: <code>[[1,2], [3,4]](2)</code> returns <code>[3,4]</code>. You can also apply the operator as many times as the list is nested. For example, <code>[[1,2], [3,4]](2)(2)</code> returns <code>4</code> and so does <code>[[1,2], [3,4]](2,2)</code>.</code></code></code><p>
<code><code><code>Elements of a list can be modified as shown in the following example. <div class="fragment"><pre class="fragment">?L = [1,2,3,4];
L(2) = 10;
?L;
</pre></div></code></code></code><p>
<code><code><code>has output</code></code></code><p>
<code><code><code><div class="fragment"><pre class="fragment">L = [1, 2, 3, 4]
L = [1, 10, 3, 4]
</pre></div></code></code></code><p>
<code><code><code>Note that <code>?L(2)</code> has as output <code>Constant -&gt; 10</code> instead of <code>Constant = 10</code>, since the return value of <code>L(2)</code> is the reference to the second element in the list and not just the value. You can also store the reference to an element of a list using the reference operator &lt;tt&gt;-&gt;</code>. For example,</code></code><p>
<code><code><div class="fragment"><pre class="fragment">?L = [1,2,3,4];
?a -&gt; L(2);
a = <span class="stringliteral">"Hello"</span>;
?L;
</pre></div></code></code><p>
<code><code>generates the output</code></code><p>
<code><code><div class="fragment"><pre class="fragment">L = [1, 2, 3, 4]
a -&gt; 2
L = [1, Hello, 3, 4]
</pre></div></code></code><p>
<code><code>This functionality can be quite useful if you need to access the same element in a list a large number of times, since it is much slower to evaluate the reference to an element of a list (as in <code>L(2)</code>), than to use the reference to an element directly.</code></code><p>
<code><code>If you have created a reference to an element of a list and then destroy the list, for example, by overwriting the respective variable with a different value, the reference variable is set to zero. Here is an example,</code></code><p>
<code><code><div class="fragment"><pre class="fragment">?L = [1,2,3,4];     <span class="comment">// Create a list and assign it to L</span>
?a -&gt; L(2);         <span class="comment">// Assign to a the reference to the second element in L</span>
L = 0;              <span class="comment">// Overwrite L with an integer value. The list from above</span>
                    <span class="comment">// does not exist anymore now, and thus the reference </span>
                    <span class="comment">// stored in a is invalid.</span>
?a;                 <span class="comment">// Hence, a is set to zero.</span>
</pre></div></code></code><p>
<code><code>generates the output</code></code><p>
<code><code><div class="fragment"><pre class="fragment">L = [1, 2, 3, 4]
a -&gt; 2
a = 0
</pre></div></code></code><p>
<code><code><table width="400" bgcolor="#EEEEEE" align="center" border="0" cellspacing="3" cellpadding="3">
<tr>
<td><b>By the way...</b> <br>
 ... a list need not only consists of element of one type. In particular, you can overwrite elements of a list with new elements of a different type. </td></tr>
</table>
</code></code><p>
<code><code>Lists of a particular structure can be created by selecting elements of a list by a string. For example,</code></code><p>
<code><code><div class="fragment"><pre class="fragment">    L = [];             <span class="comment">// Create an empty list</span>
    L(<span class="stringliteral">"Hello"</span>) = 1;     <span class="comment">// Create an element with name 'Hello'</span>
    ?L;                 <span class="comment">// Look at the list</span>
    ?L(<span class="stringliteral">"Hello"</span>);        <span class="comment">// Get value of element 'Hello'</span>
</pre></div></code></code><p>
<code><code>has as output</code></code><p>
<code><code><div class="fragment"><pre class="fragment">L = [[Hello, 1]]
Constant -&gt; 1
</pre></div></code></code><p>
<code><code>As this short script shows, when you select an element with a name that does not exist in the list, then this element is created. If it does exist, then a reference to its value is returned. The function <a class="el" href="group__grp__GAFunc.html#ga3">AnalyzeMV()</a> returns such a type of list, for example.</code></code><p>
<code><code><div class="fragment"><pre class="fragment">    P = <a class="code" href="group__grp__GAFunc.html#ga42">VecP3</a>(1,0,0)^<a class="code" href="group__grp__GAFunc.html#ga42">VecP3</a>(1,1,0)^<a class="code" href="group__grp__GAFunc.html#ga42">VecP3</a>(1,0,1);
    ?L = <a class="code" href="group__grp__GAFunc.html#ga3">AnalyzeMV</a>(P);
    ?L(<span class="stringliteral">"pos"</span>);
    ?L(<span class="stringliteral">"dir1"</span>);
    ?L(<span class="stringliteral">"dir2"</span>);
</pre></div></code></code><p>
<code><code>generates the output</code></code><p>
<code><code><div class="fragment"><pre class="fragment">L = [plane, [mag, 1.41421], [pos, [ 1^e1 ]], [dir1, [ 1^e2 ]], [dir2, [ 1^e3 ]]]
Constant -&gt; [ 1^e1 ]
Constant -&gt; [ 1^e2 ]
Constant -&gt; [ 1^e3 ]
</pre></div></code></code><p>
<code><code>This way of creating lists is somewhat similar to structs in C and C++.</code></code><p>
<code><code></code></code><h3><a class="anchor" name="subsubsec_IdxListSelection">
Element List Selection</a></h3>
<code><code> You can also extract more than one element of a list at a time by passing an index list through the selection operator. It's easiest to understand this property by showing a couple of examples. The script</code></code><p>
<code><code><div class="fragment"><pre class="fragment">?L = [[1,2], [3,4]];

?L(1);
?L([1]);
?L([[2], [1]]);
?L([[1,2], [2,1]]);
</pre></div></code></code><p>
<code><code>generates the following output</code></code><p>
<code><code><div class="fragment"><pre class="fragment">L = [[1, 2], [3, 4]]
Constant -&gt; [1, 2]
Constant = [1, 2]
Constant = [[3, 4], [1, 2]]
Constant = [2, 3]
</pre></div></code></code><p>
<code><code>You can also use the operator &lt;tt&gt;~</code> to generate an index list starting at the value given on the LHS up to the value on its RHS in interger steps of 1. For example,</code><p>
<code><div class="fragment"><pre class="fragment">?1 ~ 5;
</pre></div></code><p>
<code>results in</code><p>
<code><div class="fragment"><pre class="fragment">Constant = [[1], [2], [3], [4], [5]]
</pre></div></code><p>
<code>This may, for example, be used in the following way.</code><p>
<code><div class="fragment"><pre class="fragment">L = [1,2,4,8,16];
?L(2~4);
</pre></div></code><p>
<code>generates the output</code><p>
<code><div class="fragment"><pre class="fragment">Constant = [2, 4, 8]
</pre></div></code><p>
<code></code><h3><a class="anchor" name="subsubsec_ListExample">
List Examples</a></h3>
<code> Although this is jumping ahead a little, using lists you can rotate a list of multivectors as follows.</code><p>
<code><div class="fragment"><pre class="fragment">    <span class="comment">// Create special variables for E3</span>
    <span class="comment">// like e1, e2, e3.</span>
    <a class="code" href="group__grp__GAFunc.html#ga7">DefVarsE3</a>();

    <span class="comment">// Define some vectors</span>
    A1 = e1; A2 = e2; A3 = e3;

    <span class="comment">// Define a rotor, rotating about</span>
    <span class="comment">// the e2-axis, 20 degrees.</span>
    R = <a class="code" href="group__grp__GAFunc.html#ga22">RotorE3</a>(0, 1, 0, 20 * <a class="code" href="group__grp__MathConst.html#ga2">RadPerDeg</a>);

    <span class="comment">// Create a list of the basis vectors</span>
    Basis = [A1, A2, A3];

    <span class="comment">// Rotate all basis vectors</span>
    RBasis = R * Basis * ~R;

    <span class="comment">// And finally create a rotation matrix</span>
    <span class="comment">// from the bases.</span>
    M = <a class="code" href="group__grp__Matrix.html#ga19">Matrix</a>(Basis . RBasis);
</pre></div></code><p>
<code><code>RBasis</code> contains a list of the rotated basis vectors, and <code>M</code> is the transformation matrix from basis <code>Basis</code> to basis <code>RBasis</code>.</code><p>
<code><hr>
 </code><h2><a class="anchor" name="subsec_Strings">
Strings</a></h2>
<code> You can do a couple of more things than just display them from CLUScript v2.0 onwards. As you have probably gathered by now, strings can be concatenated using the operator <code>+</code>. Given a variable containing a string, you can also concatenate elements to this string using the operator &lt;tt&gt;&lt;&lt;</code>. For example,<p>
<div class="fragment"><pre class="fragment">    ?s = <span class="stringliteral">"Hello "</span>;
    s &lt;&lt; <span class="stringliteral">"World"</span> &lt;&lt; 2 &lt;&lt; 3;
    ?s;
</pre></div><p>
which outputs<p>
<div class="fragment"><pre class="fragment">Hello 
Hello World23
</pre></div><p>
A character in a string can be selected using the selection operator &lt;tt&gt;(). For example,<p>
<div class="fragment"><pre class="fragment">    ?s = <span class="stringliteral">"Hello"</span>;
    ?s(3);
    ?s([[2], [4], [1]]);
</pre></div><p>
gives<p>
<div class="fragment"><pre class="fragment">Hello
l
Constant = [e, l, H]
</pre></div><p>
You can also search for all positions of a substring in a string as follows.<p>
<div class="fragment"><pre class="fragment">    ?s = <span class="stringliteral">"Hello World"</span>;     <span class="comment">// The string</span>
    ?s(<span class="stringliteral">"l"</span>);    <span class="comment">// All positions of 'l' in the string s</span>
    ?s(<span class="stringliteral">"Wo"</span>);   <span class="comment">// All positions of 'Wo' in the string s</span>
</pre></div><p>
This script returns<p>
<div class="fragment"><pre class="fragment">Hello World
Constant = [3, 4, 10]
Constant = [7]
</pre></div><p>
This feature can be quite useful when you want to strip, for example, a filename returned from <a class="el" href="group__grp__File.html#ga0">FileChooser()</a> from its path and extension.<p>
<dl compact><dt><b>Attention:</b></dt><dd>From version 2.3 onwards, strings may also contain control symbols for new line ('\n'), tabulator ('\t') and the backslash itself ('\\'). This is in line with the syntax of generating a quotation mark in a string via '\"'. Make sure to check your old CLUScripts, where you wrote latex code. The backslash symbols need to be doubled now!</dd></dl>
<hr>
 <h2><a class="anchor" name="subsec_Macros">
Macros</a></h2>
This feature was introduced in CLUScript version 1.2. A CLUScript macro is the closest you can get so far to a function. There is no strict type checking when you pass parameters to macros, which can be a source of error. Nevertheless, macros facilitate many more complex operations. A macro is defined using curly brackets (<code>{ }</code>) as follows.<p>
<div class="fragment"><pre class="fragment">    <span class="comment">// Define a macro with the name Hello</span>
    Hello = { ?<span class="stringliteral">"Hello"</span>; }
    
    <span class="comment">// Execute the macro</span>
    Hello();
</pre></div><p>
This script produces the following output.<p>
<div class="fragment"><pre class="fragment">Hello
</pre></div><p>
The variable <code>Hello</code> does in fact contain a reference to the actual function. This means that you can also store the reference to the function in a list. For example,<p>
<div class="fragment"><pre class="fragment">    <span class="comment">// Define a list</span>
    L = [1,2,3];
    
    <span class="comment">// Define a macro and store a reference to it in the list L</span>
    L(2) = { ?<span class="stringliteral">"Hello"</span>; }

    <span class="comment">// What is L?</span>
    ?L;
    
    <span class="comment">// Execute the macro</span>
    L(2)();
/endcode

which produces the outpu

\code
L = [1, 030850C8, 3]
Hello
</pre></div><p>
Note that a macro is <em>not</em> executed at the point of its definition. It is also only translated once in the parsing process, such that a repeated execution of a script will not redefine a macro continuously.<p>
You can also pass any number of parameters to a macro. There is no internal process that checks whether the number and type of parameters is correct, which means that you also do not have to declare the number and type of parameters expected when you define a macro. Parameters are passed to a macro in the same way as to any other function: a comma separated list within the round brackets. That is, <code>Hello(1,b)</code> passes the parameters <code>1</code> and <code>b</code> to the macro. Whether the macro uses these parameters or not, does not matter. Within the macro a variable list called <code>_P</code> is always available, which contains the parameters passed to the macro. You can access the different parameters with the selection operator &lt;tt&gt;(), just as for any other variable list. Another code example should clarify this.<p>
<div class="fragment"><pre class="fragment">    <span class="comment">// Define a macro with the name Hello</span>
    Hello = { ?<span class="stringliteral">"Hello "</span> + _P(1); }  <span class="comment">// Add the first parameter to the string</span>
    
    <span class="comment">// Execute the macro</span>
    <span class="comment">// The following type of call would cause an error,</span>
    <span class="comment">// since the macro uses the first parameter, which </span>
    <span class="comment">// does not exist.</span>
    <span class="comment">// Hello();     </span>
    
    <span class="comment">// This is how you would use the macro 'Hello'</span>
    Hello(<span class="stringliteral">"World"</span>);
    
    <span class="comment">// The following does not cause an error.</span>
    <span class="comment">// The macro simply ignores the second parameter.</span>
    <span class="comment">// Hello("World", 2); </span>
</pre></div><p>
generates the output<p>
<div class="fragment"><pre class="fragment">Hello World
</pre></div><p>
If you define variables in a script, then they are strictly local. That is, in CLUScript v2.0 you can no longer access global variables by simply using their variable name in a function. For example,<p>
<div class="fragment"><pre class="fragment">    a = 1;      <span class="comment">// global variable a</span>

    func =      <span class="comment">// define macro</span>
    { 
        ?a;         <span class="comment">// This creates a local variable a</span>
        ?a = 2;     <span class="comment">// Set local 'a' to 2</span>
        ?b = 1;     <span class="comment">// Create local variable b</span>
    }   

    func();     <span class="comment">// execute macro</span>
    ?a;         <span class="comment">// global variable 'a'</span>
    ?b;         <span class="comment">// global variable 'b'</span>
</pre></div><p>
The output of this script is<p>
<div class="fragment"><pre class="fragment">a = 0
a = 2
b = 1
a = 1
b = 0
</pre></div><p>
The variables defined inside the macro only exist within the macro and also do not relate to global variables of the same name. You can, however, refer to global variables from within a macro by writing <code>::</code> in front of the respective variable name. For example, here is a modified version of the previous script.<p>
<div class="fragment"><pre class="fragment">    a = 1;      <span class="comment">// global variable a</span>

    func =      <span class="comment">// define macro</span>
    { 
        ?a = 1;     <span class="comment">// This creates a local variable 'a'</span>
        ?::a = 2;   <span class="comment">// Set global 'a' to 2</span>
        ?a;
        ?::b = 1;   <span class="comment">// Create global variable b</span>
    }   

    func();     <span class="comment">// execute macro</span>
    ?a;         <span class="comment">// global variable 'a'</span>
    ?b;         <span class="comment">// global variable 'b'</span>
</pre></div><p>
This time the output of the script is<p>
<div class="fragment"><pre class="fragment">a = 1
a = 2
a = 1
b = 1
a = 2
b = 1
</pre></div><p>
<dl compact><dt><b>Attention:</b></dt><dd>The variables defined through calls of <a class="el" href="group__grp__GAFunc.html#ga7">DefVarsE3()</a>, <a class="el" href="group__grp__GAFunc.html#ga9">DefVarsP3()</a>, <a class="el" href="group__grp__GAFunc.html#ga8">DefVarsN3()</a> and <a class="el" href="group__grp__GAFunc.html#ga6">DefVarsC2()</a>, as well as all predefined variables are accesible without leading <code>::</code> from within macros.</dd></dl>
Note that references to macros are usually also stored in global variable. Hence, if you want to call a macro from within another macro you often also have to use <code>::</code> in front of the macro name. Here is an example,<p>
<div class="fragment"><pre class="fragment">    func1 = { ?<span class="stringliteral">"Hello"</span>; }
    func2 = 
    { 
        <span class="comment">// Define a local version of func1</span>
        func1 = { ?<span class="stringliteral">"Hola"</span>; }
        
        func1();    <span class="comment">// Call local macro stored in func1</span>
        ::func1();  <span class="comment">// Call global macro stored in ::func1</span>
        ?<span class="stringliteral">"World"</span>; 
    }
    
    func2();    <span class="comment">// Execute func2</span>
</pre></div><p>
which produces the output<p>
<div class="fragment"><pre class="fragment">Hola
Hello
World
</pre></div><p>
Of course, a macro can contain more than a single line. As shown above, you can write a whole block of code, with lines separated by semicolons, within the curly brackets. The return value of a macro is the result of the last command line, <b>if this line does not end with a semicolon</b>. For example,<p>
<div class="fragment"><pre class="fragment">    <span class="comment">// Define a macro with the name Rot2D</span>
    <span class="comment">// to rotate 2d-coordinates of a point.</span>
    <span class="comment">// Expected parameters: (x, y, angle)</span>
    Rot2D = 
    { 
        <span class="comment">// Copy the parameters</span>
        x = _P(1); y = _P(2); angle = _P(3);
        
        <span class="comment">// Rotate</span>
        a = x*<a class="code" href="group__grp__MathFunc.html#ga16">cos</a>(angle) - y*<a class="code" href="group__grp__MathFunc.html#ga44">sin</a>(angle);
        b = x*<a class="code" href="group__grp__MathFunc.html#ga44">sin</a>(angle) + y*<a class="code" href="group__grp__MathFunc.html#ga16">cos</a>(angle);
        
        <span class="comment">// Return the pair (a, b)</span>
        (a, b) 
    }

    <span class="comment">// Now we can rotate in 2D</span>
    ?Rot2D(1, 0, 45*<a class="code" href="group__grp__MathConst.html#ga2">RadPerDeg</a>);
</pre></div><p>
The output of this script is <div class="fragment"><pre class="fragment">Constant = (0.707107, 0.707107)
</pre></div><p>
You can also return different values at different places of a script using the <code>break</code> keyword. Here is an example,<p>
<div class="fragment"><pre class="fragment">    func = 
    {
        <span class="comment">// If the first parameter is negative then</span>
        <span class="comment">// return -1</span>
        <span class="keywordflow">if</span> (_P(1) &lt; 0)  
            (-1) <span class="keywordflow">break</span>;
            
        <span class="comment">// otherwise return the square root of the first parameter</span>
        <a class="code" href="group__grp__MathFunc.html#ga47">sqrt</a>(_P(1))
    }
    
    ?func(-4);
    ?func(4);
</pre></div><p>
which returns<p>
<div class="fragment"><pre class="fragment">Constant = -1
Constant = 2
</pre></div><p>
Another new feature of CLUScript v2.0 is that variables are passed to macros by reference. This means that you can change parameters that are passed to a function. Here is an example,<p>
<div class="fragment"><pre class="fragment">    <span class="comment">// This macro increments the variable passed</span>
    Incr = 
    { 
        a -&gt; _P(1); <span class="comment">// Get reference to first parameter</span>
        a = a + 1;  <span class="comment">// Increment first parameter</span>
    }
    
    ?x = 1;
    Incr(x);
    ?x;
</pre></div><p>
which returns<p>
<div class="fragment"><pre class="fragment">x = 1
x = 2
</pre></div><p>
References to parameters are also useful if you need to access the parameters at many places in a macro.<p>
Macros are particularly useful if you want to execute the same complex calculation at different places in the script. They can also make the <code>Plot</code> command better readable.<p>
Another nice features of macros is that you can also pass them as parameters to other macros. This works because if you define <code>func = { //... }</code>, then <code>func</code> is simply a variable that contains a referecnce to the code enclosed in the curly brackets. The reference itself is of no interest, but it can be treated like a standard variable. In the next example we pass one function to another one.<p>
<div class="fragment"><pre class="fragment">    <a class="code" href="group__grp__VarEnv.html#ga0">_2dView</a> = 1;
    <a class="code" href="group__grp__VarEnv.html#ga1">_BGColor</a> = <a class="code" href="group__grp__ColVars.html#ga8">White</a>;
    
    <a class="code" href="group__grp__GAFunc.html#ga7">DefVarsE3</a>();

    <span class="comment">// Define my own plotting of functions</span>
    MyPlot = 
    {
        <span class="comment">// The first parameter needs to be the function</span>
        f = _P(1);
        <span class="keywordflow">if</span> (<a class="code" href="group__grp__Misc.html#ga13">Type</a>(f) != <span class="stringliteral">"code"</span>)
        {
            <span class="comment">// Error message</span>
            ?<span class="stringliteral">"Expect function as first parameter."</span>;
            <span class="comment">// end this macro</span>
            <span class="keywordflow">break</span>;
        }
        
        <span class="comment">// The minimum, maximum and step values</span>
        minval = _P(2);
        maxval = _P(3);
        step = _P(4);

        <span class="comment">// Loop over positions in range and add</span>
        <span class="comment">// function values to list.</span>
        pos = minval;
        Data = f(pos);
        loop
        {
            pos = pos + step;
            <span class="keywordflow">if</span> (pos &gt; maxval)
                <span class="keywordflow">break</span>;
        
            Data &lt;&lt; f(pos);
        }

        <span class="comment">// Draw the list of data points</span>
        <a class="code" href="group__grp__DrawFunc.html#ga25">DrawPointList</a>(Data);
    }

    <span class="comment">// The function we want to plot</span>
    func = 
    {
        x -&gt; _P(1);
        
        <span class="comment">// Return value</span>
        x*e1 + (1 - x + <a class="code" href="group__grp__MathFunc.html#ga44">sin</a>(x*x))*e2 
    }

    :<a class="code" href="group__grp__ColVars.html#ga9">Black</a>;
    
    <span class="comment">// Now plot the function</span>
    MyPlot(func, -2, 2, 0.1);
</pre></div><p>
which produces the visualization<p>
<div align="center">
<img src="MacroEx1.jpg" alt="MacroEx1.jpg">
</div>
<p>
A macro like <code>MyPlot</code> may be stored in a separate file and included in a script via the <code>include</code> preprocessor directive (see <a class="el" href="group__grp__PreProc.html">Preprocessor Directives</a>), whenever it is needed.<p>
It is also possible to do a kind of object oriented programming using structured lists. Have a look at the following script.<p>
<div class="fragment"><pre class="fragment">    func =
    {
        <span class="keyword">this</span> -&gt; _P(1);
        
        ?<span class="stringliteral">"The name is '"</span> + <span class="keyword">this</span>(<span class="stringliteral">"name"</span>) + <span class="stringliteral">"'"</span>;
    }
    
    C = [];
    C(<span class="stringliteral">"name"</span>) = <span class="stringliteral">"My first list"</span>;
    C(<span class="stringliteral">"print"</span>) = func;
    
    <span class="comment">// Execute macro 'func' and pass as first parameter</span>
    <span class="comment">// the structured list itself.</span>
    C(<span class="stringliteral">"print"</span>)(C);  
</pre></div><p>
This produces the output<p>
<div class="fragment"><pre class="fragment">The name is 'My first list'
</pre></div> </body></html>
