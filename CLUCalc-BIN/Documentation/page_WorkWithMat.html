<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
	<title>CLUCalc: CLUCalc - A Visual Calculator</title>
	<link href="doxygen.css" rel="stylesheet" type="text/css">
	<link href="favicon.ico" rel="SHORTCUT ICON">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1><a class="anchor" name="page_WorkWithMat">Working with Matrices</a></h1><ul>
<li>
<a class="el" href="page_WorkWithMat.html#sec_MatrixBasics">The Basics</a> </li>
<li>
<a class="el" href="page_WorkWithMat.html#sec_MatrixPointOperators">Point Operators and Matrices</a> </li>
<li>
<a class="el" href="page_WorkWithMat.html#sec_MatrixLogic">Logic Operations</a> </li>
<li>
<a class="el" href="page_WorkWithMat.html#sec_MatrixPrint">Printing Matrices</a> </li>
<li>
<a class="el" href="page_WorkWithMat.html#sec_MatrixExamples">Examples</a> </li>
</ul>
<p>
So far only simple matrix operations are implemented in CLUScript. Matrices where mainly implemented in order to show the connection between Clifford algebra and Matrices, i.e. linear algebra. It is also possible to visualize the range of <img class="formulaInl" alt="$3\times 3$" src="form_125.png"> matrices.<p>
<hr>
 <h2><a class="anchor" name="sec_MatrixBasics">
The Basics</a></h2>
For matrices the following operators are defined: addition <code>+</code>, subtraction and negation <code>-</code>, matrix multiplication <code>*</code>, transposition <code>~</code> and inversion <code>!</code>. If a matrix has no inverse the inversion operator returns the "next best" inverse, i.e. the pseudo-inverse. Matrix division <code>/</code> is also defined, whereby <img class="formulaInl" alt="$A / B = A B^{-1}$" src="form_126.png"> , just as for multivectors.<p>
A matrix is created with the function <code>Matrix</code> which expects either one or two parameters. If you call <code>Matrix</code> with a single parameter then this parameter has to be a nested list of order two, i.e. something like <code>[[1,2], [3,4]]</code>. Each sublist represents a row of the matrix. Matrices do not have to be square but each row must have the same number of elements. You may also call <code>Matrix</code> with two counter parameters. In that case the function returns a matrix of the given number of rows and columns, where every element is set to zero. For example, <code>Matrix(2,3)</code> returns a <img class="formulaInl" alt="$2\times 3$" src="form_127.png"> null matrix.<p>
You can also change the value of matrix components using the selection operator &lt;tt&gt;(). For example, given that <code>M</code> is a 3 by 3 matrix, the value of the matrix at row two and column three can be set to a particular value by writing <code>M(2,3) = 5.2</code>. Here is a code example,<p>
<div class="fragment"><pre class="fragment">?M = <a class="code" href="group__grp__Matrix.html#ga19">Matrix</a>( [[1,2], [3,4]] );
M(1,2) = 10;
?M;
</pre></div><p>
This produces the following output. <div class="fragment"><pre class="fragment">M = (| 1 2|, | 3 4|)
M = (| 1 10|, | 3 4|)
</pre></div><p>
You can also extract the i'th row of a matrix by passing the row index as only parameter to the selection operator. That is, if <code>M</code> is a matrix variable, then <code>M(2)</code> returns the second row. For example,<p>
<div class="fragment"><pre class="fragment">?M = <a class="code" href="group__grp__Matrix.html#ga19">Matrix</a>( [[1,2], [3,4]] );
?M(2);
</pre></div><p>
produces the output<p>
<div class="fragment"><pre class="fragment">M = (| 1 2|, | 3 4|)
Constant = (| 3 4|)
</pre></div><p>
A submatrix can be extracted by passing four parameters. If <code>M</code> is a matrix variable then <code>M(i,j, m,n)</code> returns the submatrix of <code>M</code> starting at row <code>i</code> and column <code>j</code>, and extending over <code>m</code> rows and <code>n</code> columns. A column of a matrix can thus be extracted via<p>
<div class="fragment"><pre class="fragment">?M = <a class="code" href="group__grp__Matrix.html#ga19">Matrix</a>( [[1,2,3], [4,5,6], [7,8,9]] );
?M(1,2, 3,1);   <span class="comment">// Second row of M</span>
</pre></div><p>
gives<p>
<div class="fragment"><pre class="fragment">M = (| 1 2 3|, | 4 5 6|, | 7 8 9|)
Constant = (| 2|, | 5|, | 8|)
</pre></div><p>
Just as for lists, it is also possible to extract a number of elements of a matrix at the same time using an index list. Here is an example,<p>
<div class="fragment"><pre class="fragment">?M = <a class="code" href="group__grp__Matrix.html#ga19">Matrix</a>( [[1,2,3], [4,5,6], [7,8,9]] );
?M([ [1,2],  Row 1, Col. 2 
     [3,1]]  Row 3, Col. 1 );    
</pre></div><p>
which results in<p>
<div class="fragment"><pre class="fragment">M = (| 1 2 3|, | 4 5 6|, | 7 8 9|)
Constant = [2, 7]
</pre></div><p>
In much the same way you can also extract a list of rows, or a list of submatrices.<p>
<div class="fragment"><pre class="fragment">?M = <a class="code" href="group__grp__Matrix.html#ga19">Matrix</a>( [[1,2,3], [4,5,6], [7,8,9]] );

?M([ [1],  Row 1 
     [3]]  Row 3 );

?M([ [2,2,2,2], [1,1,2,2] ]);
</pre></div><p>
produces the output<p>
<div class="fragment"><pre class="fragment">M = (| 1 2 3|, | 4 5 6|, | 7 8 9|)
Constant = [(| 1 2 3|), (| 7 8 9|)]
Constant = [(| 5 6|, | 8 9|), (| 1 2|, | 4 5|)]
</pre></div><p>
Of course, you can also mix lists. For example, the script<p>
<div class="fragment"><pre class="fragment">?M = <a class="code" href="group__grp__Matrix.html#ga19">Matrix</a>( [[1,2,3], [4,5,6], [7,8,9]] );

?M([ [1],        Row 1 
     [2,3],      Element Row 2, Col. 3 
     [1,2,3,1]]  Second column 
     );
</pre></div><p>
results in<p>
<div class="fragment"><pre class="fragment">M = (| 1 2 3|, | 4 5 6|, | 7 8 9|)
Constant = [(| 1 2 3|), 6, (| 2|, | 5|, | 8|)]
</pre></div><p>
<hr>
 <h2><a class="anchor" name="sec_MatrixPointOperators">
Point Operators and Matrices</a></h2>
In section <a class="el" href="page_TheLanguage.html#subsec_Operators">Operators</a> so called point operators were introduced. In this section we will discuss their application with respect to matrices in some more detail. As always we will start with an example. The matrix product of two matrices is evaluated using the operator <code>*</code>. In some cases it is, however, useful to multiply two matrices element wise. This can be done with the point version of the product operator. Here is a code example.<p>
<div class="fragment"><pre class="fragment">?M1 = <a class="code" href="group__grp__Matrix.html#ga19">Matrix</a>( [[1,2], [3,4]] );
?M2 = <a class="code" href="group__grp__Matrix.html#ga19">Matrix</a>( [[1,0], [0,1]] );

?M1 * M2;   <span class="comment">// The matrix product</span>
?M1 .* M2;  <span class="comment">// The element wise product</span>
</pre></div><p>
This produces the output<p>
<b>M1</b> &lt;font size="12"&gt;<em>(2x2)</em>&lt;/font&gt; = &lt;font size="12"&gt;<table border="1" cellspacing="3" cellpadding="3">
<tr>
<td>1</td><td>2</td></tr>
<tr>
<td>3</td><td>4 </td></tr>
</table>
.<br>
&lt;/font&gt;<br>
<b>M2</b> &lt;font size="12"&gt;<em>(2x2)</em>&lt;/font&gt; = &lt;font size="12"&gt;<table border="1" cellspacing="3" cellpadding="3">
<tr>
<td>1</td><td>0</td></tr>
<tr>
<td>0</td><td>1 </td></tr>
</table>
.<br>
&lt;/font&gt;<br>
<b>Constant</b> &lt;font size="12"&gt;<em>(2x2)</em>&lt;/font&gt; = &lt;font size="12"&gt;<table border="1" cellspacing="3" cellpadding="3">
<tr>
<td>1</td><td>2</td></tr>
<tr>
<td>3</td><td>4 </td></tr>
</table>
.<br>
&lt;/font&gt;<br>
<b>Constant</b> &lt;font size="12"&gt;<em>(2x2)</em>&lt;/font&gt; = &lt;font size="12"&gt;<table border="1" cellspacing="3" cellpadding="3">
<tr>
<td>1</td><td>0</td></tr>
<tr>
<td>0</td><td>4 </td></tr>
</table>
.<br>
&lt;/font&gt;<br>
<p>
Note that there is a special behaviour for the point operators <code>.*</code> and <code>./</code> when the RHS matrix consists of a single column. In that case, the value of the RHS matrix in row <code>i</code> is applied to all elements in the same row of the LHS matrix. Here is an example.<p>
<div class="fragment"><pre class="fragment">?M1 = <a class="code" href="group__grp__Matrix.html#ga19">Matrix</a>( [[1,2], [3,4]] );
?M2 = <a class="code" href="group__grp__Matrix.html#ga19">Matrix</a>( [1,2] );

?M1 .* M2;
?M1 ./ M2;
</pre></div><p>
This produces the output<p>
<b>M1</b> &lt;font size="12"&gt;<em>(2x2)</em>&lt;/font&gt; = &lt;font size="12"&gt;<table border="1" cellspacing="3" cellpadding="3">
<tr>
<td>1</td><td>2</td></tr>
<tr>
<td>3</td><td>4 </td></tr>
</table>
.<br>
&lt;/font&gt;<br>
<b>M2</b> &lt;font size="12"&gt;<em>(2x1)</em>&lt;/font&gt; = &lt;font size="12"&gt;<table border="1" cellspacing="3" cellpadding="3">
<tr>
<td>1</td></tr>
<tr>
<td>2 </td></tr>
</table>
.<br>
&lt;/font&gt;<br>
<b>Constant</b> &lt;font size="12"&gt;<em>(2x2)</em>&lt;/font&gt; = &lt;font size="12"&gt;<table border="1" cellspacing="3" cellpadding="3">
<tr>
<td>1</td><td>2</td></tr>
<tr>
<td>6</td><td>8 </td></tr>
</table>
.<br>
&lt;/font&gt;<br>
<b>Constant</b> &lt;font size="12"&gt;<em>(2x2)</em>&lt;/font&gt; = &lt;font size="12"&gt;<table border="1" cellspacing="3" cellpadding="3">
<tr>
<td>1</td><td>2</td></tr>
<tr>
<td>1.5</td><td>2 </td></tr>
</table>
.<br>
&lt;/font&gt;<br>
<p>
The other point operators have the same element wise behaviour. Note that the point operators <code>.+</code> and <code>.-</code> are equivalent to <code>+</code> and <code>-</code> when applied to matrices. The only other point operators that are useful for matrices are logic point operators, which will be discussed in the next section.<p>
<hr>
 <h2><a class="anchor" name="sec_MatrixLogic">
Logic Operations</a></h2>
New in CLUScript v2.0 is the possibility to apply logic operators like <code>!!</code> and <code>&gt;</code> to matrices. The standard logic operators are <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>==</code>, <code>!=</code>. All of these can be applied between a matrix on the LHS and a scalar value on the RHS. The operators <code>==</code> and <code>!=</code> can also be applied between two matrices. If a logic operator is applied between a matrix and a scalar, it is applied to each element of the matrix and the result of the logic operation is written into a new matrix. For example,<p>
<div class="fragment"><pre class="fragment">?M = <a class="code" href="group__grp__Matrix.html#ga19">Matrix</a>( [[1,2], [3,4]] );
?M &gt; 2;
?M &lt; 2;
?M == 2;
?M != 2;
</pre></div><p>
gives<p>
<div class="fragment"><pre class="fragment">M = (| 1 2|, | 3 4|)
Constant = (| 0 0|, | 1 1|)
Constant = (| 1 0|, | 0 0|)
Constant = (| 0 1|, | 0 0|)
Constant = (| 1 0|, | 1 1|)
</pre></div><p>
The matrices that are returned from such a logic operation can be used to find the positions in a matrix where a logic condition is true. This is done with the function <a class="el" href="group__grp__Logic.html#ga4">argtrue()</a>, which returns all those positions of a matrix where the entries are not zero. For example,<p>
<div class="fragment"><pre class="fragment">?M = <a class="code" href="group__grp__Matrix.html#ga19">Matrix</a>( [[1,2], [3,4]] );
?T = M &gt; 2;
?<a class="code" href="group__grp__Logic.html#ga4">argtrue</a>(T);
</pre></div><p>
gives<p>
<div class="fragment"><pre class="fragment">M = (| 1 2|, | 3 4|)
T = (| 0 0|, | 1 1|)
Constant = [[2, 1], [2, 2]]
</pre></div><p>
We can then also extract just those values where a condition was true, since <a class="el" href="group__grp__Logic.html#ga4">argtrue()</a> returns an index list.<p>
<div class="fragment"><pre class="fragment">?M = <a class="code" href="group__grp__Matrix.html#ga19">Matrix</a>( [[1,2], [3,4]] );
?M(<a class="code" href="group__grp__Logic.html#ga4">argtrue</a>(M &gt; 2));
</pre></div><p>
gives<p>
<div class="fragment"><pre class="fragment">M = (| 1 2|, | 3 4|)
Constant = [3, 4]
</pre></div><p>
More complex logical conditions can be evaluated using the logic point operators <code>.==</code>, <code>.!=</code>, <code>.&lt;</code>, <code>.&gt;</code>, <code>.&lt;=</code>, <code>.&gt;=</code>, <code>.&amp;&amp;</code>,<code>.||</code>, and the logic operator &lt;tt&gt;!!. These point operators are applied between two matrices and evaluate their respective logic operation element wise. For example, suppose you are interested in those elements of a matrix that are greater than 2 and smaller or equal than 5. This can be evaluated as follows.<p>
<div class="fragment"><pre class="fragment">?M = <a class="code" href="group__grp__Matrix.html#ga19">Matrix</a>( [[1,2,3], [4,5,6], [7,8,9]] );
? M &gt; 2 .&amp;&amp; M &lt;= 5;
</pre></div><p>
gives<p>
<div class="fragment"><pre class="fragment">M = (| 1 2 3|, | 4 5 6|, | 7 8 9|)
Constant = (| 0 0 1|, | 1 1 0|, | 0 0 0|)
</pre></div><p>
Note that the operator &lt;tt&gt;!! is applied element wise to matrices, whereby zero elements are set to unity, and all other elements are set to zero.<p>
<hr>
 <h2><a class="anchor" name="sec_MatrixPrint">
Printing Matrices</a></h2>
When you are working with large matrices, it can be quite helpful to print them as a whole. This is currently not possible in the output window. However, you can print a matrix in the visualization window using the <a class="el" href="group__grp__LatexFunc.html#ga4">Latex()</a> and <a class="el" href="group__grp__LatexFunc.html#ga1">DrawLatex()</a> functions. The function <a class="el" href="group__grp__LatexFunc.html#ga4">Latex()</a> translates a matrix into a latex string, and the function <a class="el" href="group__grp__LatexFunc.html#ga1">DrawLatex()</a> can draw that string using latex. Here is an example,<p>
<div class="fragment"><pre class="fragment">    X = <a class="code" href="group__grp__GAFunc.html#ga42">VecP3</a>(1,2,3);
    M = <a class="code" href="group__grp__Matrix.html#ga13">GetMVProductMatrix</a>(X, <a class="code" href="group__grp__OpIDs.html#ga1">MVOP_GEO</a>);

    <span class="comment">// Start an overlay in order to draw the matrix</span>
    <span class="comment">// indepedently of the rotation and translation</span>
    <span class="comment">// of the frame.</span>
    <a class="code" href="group__grp__DrawFunc.html#ga62">StartOverlay</a>();
    :<a class="code" href="group__grp__ColVars.html#ga8">White</a>;
    <a class="code" href="group__grp__LatexFunc.html#ga5">SetLatexAlign</a>(0,1); <span class="comment">// Top align latex drawing</span>
    <a class="code" href="group__grp__LatexFunc.html#ga6">SetLatexMagStep</a>(5); <span class="comment">// Set size of latex font</span>
    <a class="code" href="group__grp__LatexFunc.html#ga1">DrawLatex</a>(5, 5, 0, <span class="stringliteral">"$"</span> + <a class="code" href="group__grp__LatexFunc.html#ga4">Latex</a>(M) + <span class="stringliteral">"$"</span>, <span class="stringliteral">"mat"</span>);
    <a class="code" href="group__grp__DrawFunc.html#ga35">EndOverlay</a>();
</pre></div><p>
which produces the following visualization<p>
<div align="center">
<img src="MatrixDrawEx1.jpg" alt="MatrixDrawEx1.jpg">
</div>
<p>
Do not forget to force the rendering of latex when parsing this file by pressing <b>ctrl + shift + p</b>.<p>
<hr>
 <h2><a class="anchor" name="sec_MatrixExamples">
Examples</a></h2>
The singular value decomposition of a matrix has been implemented through the function <code>SVD</code>. This function expects a single parameter <img class="formulaInl" alt="$M$" src="form_46.png"> , say, which is a matrix. It returns a variable list of three matrices in the order <img class="formulaInl" alt="$U$" src="form_77.png"> , <img class="formulaInl" alt="$D$" src="form_128.png"> , <img class="formulaInl" alt="$V$" src="form_70.png"> , such that <img class="formulaInl" alt="$M = UDV^T$" src="form_75.png"> and <img class="formulaInl" alt="$UU^T = VV^T = I$" src="form_76.png"> . The columns of the three matrices <img class="formulaInl" alt="$U$" src="form_77.png"> , <img class="formulaInl" alt="$D$" src="form_128.png"> , <img class="formulaInl" alt="$V$" src="form_70.png"> are ordered such that the elements of <img class="formulaInl" alt="$D$" src="form_128.png"> are given in ascending order. The following example script can be found under <code>MatrixSVD.clu</code><code>.</code><p>
<code><div class="fragment"><pre class="fragment">    <span class="comment">// Create matrix</span>
    ?M = <a class="code" href="group__grp__Matrix.html#ga19">Matrix</a>( [[1,2], [3,4]] );

    <span class="comment">// Find SVD</span>
    <a class="code" href="group__grp__List.html#ga3">List</a> = <a class="code" href="group__grp__Matrix.html#ga33">SVD</a>(M);

    <span class="comment">// Print Matrices</span>
    ?U = <a class="code" href="group__grp__List.html#ga3">List</a>(1);
    D = <a class="code" href="group__grp__List.html#ga3">List</a>(2);
    ?V = <a class="code" href="group__grp__List.html#ga3">List</a>(3);

    <span class="comment">// Print diagonal</span>
    ?Diag = [D(1,1), D(2,2)];

    <span class="comment">// Did it work?</span>
    ?U * D * ~V;
    ?U * ~U;
    ?V * ~V;
</pre></div></code><p>
<code>The eigenvalues and eigenvectors of a matrix can be evaluated with the function <a class="el" href="group__grp__Matrix.html#ga8">Eigen()</a>. If you are only interested in the eigenvalues of a matrix, you can use the faster function <a class="el" href="group__grp__Matrix.html#ga10">EigenValues()</a>. Internally both functions use LAPACK functions for the evaluation of eigenvectors and eigenvalues. Since in CLUScript complex numbers can not be represented, the real and imaginary parts of the eigenvalues and -vectors are returned separately in a list. Here is an example.</code><p>
<code><div class="fragment"><pre class="fragment">    M = <a class="code" href="group__grp__Matrix.html#ga19">Matrix</a>( [[1,2], [2,3]] );

    <span class="comment">// List of eigenvalues and eigenvectors</span>
    ?E = <a class="code" href="group__grp__Matrix.html#ga8">Eigen</a>(M); 

    ?Eval = E(1);   <span class="comment">// Real part of eigenvalues</span>
    ?Evec = E(3);   <span class="comment">// Real part of eigenvectors</span>

    <span class="comment">// Eigenvectors are normalized, which</span>
    <span class="comment">// is checked in the following line.</span>
    ?Evec * ~Evec;

    <span class="comment">// Check whether eigenvectors and </span>
    <span class="comment">// eigenvalues were calculated correctly.</span>
    <span class="comment">// The next two lines should return the </span>
    <span class="comment">// same matrix</span>
    ?M * Evec;
    ?Evec * <a class="code" href="group__grp__Matrix.html#ga30">Row2Diag</a>(Eval);
</pre></div></code><p>
<code>which returns</code><p>
<code><div class="fragment"><pre class="fragment">E = [(| -0.236068 4.236068|), (| 0 0|), (| -0.850651 -0.525731|, | 0.525731 -0.850651|), (| 0 0|, | 0 0|)]
Eval = (| -0.236068 4.236068|)
Evec = (| -0.850651 -0.525731|, | 0.525731 -0.850651|)
Constant = (| 1 0|, | 0 1|)
Constant = (| 0.200811 -2.227033|, | -0.124108 -3.603415|)
Constant = (| 0.200811 -2.227033|, | -0.124108 -3.603415|)
</pre></div></code><p>
<code>The range of <img class="formulaInl" alt="$3\times 3$" src="form_125.png"> matrices can also be visualized. The visualization routine performs a singular value decomposition on the matrix and then draws the subspace spanned by those vectors in the <img class="formulaInl" alt="$V$" src="form_70.png"> matrix that have a non-zero corresponding singular value. To visualize a <img class="formulaInl" alt="$3\times 3$" src="form_125.png"> matrix simply use the colon operator. For example,</code><p>
<code><div class="fragment"><pre class="fragment">M = <a class="code" href="group__grp__Matrix.html#ga19">Matrix</a>( [[1,2,3], [1,2,4], [2,4,6]] );
:M :<a class="code" href="group__grp__ColVars.html#ga5">Yellow</a>;
</pre></div> </code></body></html>
