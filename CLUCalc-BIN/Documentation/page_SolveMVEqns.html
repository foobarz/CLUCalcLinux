<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
	<title>CLUCalc: CLUCalc - A Visual Calculator</title>
	<link href="doxygen.css" rel="stylesheet" type="text/css">
	<link href="favicon.ico" rel="SHORTCUT ICON">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1><a class="anchor" name="page_SolveMVEqns">Solving Multivector Equations</a></h1>On this page, various aspects of solving multivector equations are discussed. So far, only linear equations can be solved. The method used is fairly simply but quite powerful at the same time. For more details than can be presented here, see the technical report <em>"Aspects of Clifford Algebra in Euclidean, Projective and Conformal Space"</em> by C. Perwass and D. Hildenbrand, which can be downloaded from the <a href="http://www.ks.informatik.uni-kiel.de/modules.php/name+Mitarbeiter,func+hp,mid+7" target="_blank">Cognitive Systems Group Kiel</a> webpage. The following text is structured as follows.<p>
<ol>
<li>
<a class="el" href="page_SolveMVEqns.html#sec_SolveMV_Intro">Introduction</a> </li>
<li>
<a class="el" href="page_SolveMVEqns.html#sec_SolveMV_LinEqn">Solving Linear Equations</a> </li>
<li>
<a class="el" href="page_SolveMVEqns.html#sec_SolveMV_VersorEqn">Solving Versor Equations</a> </li>
</ol>
<p>
<hr>
<h2><a class="anchor" name="sec_SolveMV_Intro">
Introduction</a></h2>
To explain how this works, I need to introduce some maths. The Clifford algebra over an n-dimensional vector space has dimension <img class="formulaInl" alt="$2^n$" src="form_40.png"> . Hence, the algebra has a <img class="formulaInl" alt="$2^n$" src="form_40.png"> -dimensional basis. If we denote the basis vectors by <img class="formulaInl" alt="$\{E_i\}_{i=1}^{2^n}$" src="form_97.png"> , then a general multivector can be expressed as <p class="formulaDsp">
<img class="formulaDsp" alt="\[ A = \sum_{i=1}^{2^n}\;\alpha^i\, E_i, \]" src="form_98.png">
<p>
 where the <img class="formulaInl" alt="$\{\alpha^i\}$" src="form_99.png"> are scalar components. The geometric, inner and outer products between multivectors are basically bilinear functions that can be written as follows. <p class="formulaDsp">
<img class="formulaDsp" alt="\[ A\circ B = \sum_{k=1}^{2^n}\,\sum_{i=1}^{2^n}\,\sum_{j=1}^{2^n}\; \alpha^i\,\beta^j\; {g^k}_{ij}\,E_k, \]" src="form_100.png">
<p>
 where <img class="formulaInl" alt="$\circ$" src="form_101.png"> stands for any bilinear product in Clifford algebra and <img class="formulaInl" alt="${g^k}_{ij}$" src="form_102.png"> is a 3-valence tensor whose entries are either minus one, zero or one. This tensor encodes the particular bilinear product.<p>
What the function <code>GetMVProductMatrix</code> does is, given a multivector <img class="formulaInl" alt="$A$" src="form_2.png"> and a particular product, to evaluate the matrix <p class="formulaDsp">
<img class="formulaDsp" alt="\[ {h^k}_j = \sum_{i=1}^{2^n}\;\alpha^i\,{g^k}_{ij}, \]" src="form_103.png">
<p>
 where the <img class="formulaInl" alt="$\{\alpha^i\}$" src="form_99.png"> are the components of the multivector <img class="formulaInl" alt="$A$" src="form_2.png"> . The idea is that this allows you to solve multivector equations like <img class="formulaInl" alt="$A\,\circ\,X = B$" src="form_104.png"> for <img class="formulaInl" alt="$X$" src="form_105.png"> . This becomes clear when we write down this equation in terms of components. <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \sum_{i=1}^{2^n}\,\sum_{j=1}^{2^n}\; \alpha^i\,\xi^j\; {g^k}_{ij} = \beta^k\quad \forall\,k. \]" src="form_106.png">
<p>
 If we write this as <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \sum_{j=1}^{2^n}\; \xi^j\; {h^k}_{j} = \beta^k\quad \forall\,k, \]" src="form_107.png">
<p>
 where <img class="formulaInl" alt="${h^k}_j$" src="form_108.png"> is defined as above, then this is a simple matrix equation which can be solved by inverting the matrix <img class="formulaInl" alt="${h^k}_j$" src="form_108.png"> . Note that if the multivector <img class="formulaInl" alt="$B$" src="form_89.png"> in this example were simply the scalar 1, then this method gives you the inverse of the multivector <img class="formulaInl" alt="$A$" src="form_2.png"> .<h2><a class="anchor" name="sec_SolveMV_LinEqn">
Solving Linear Equations</a></h2>
Note that in general multivectors are not invertible. Furthermore, if you are looking for solutions of <img class="formulaInl" alt="$X$" src="form_105.png"> in an equation of the form <img class="formulaInl" alt="$A\,X = 0$" src="form_109.png"> , the solution will in general not be unique. The are two things you can do to enforce uniqueness. First of all you can use a number of concurrent equations that <img class="formulaInl" alt="$X$" src="form_105.png"> has to satisfy. This may be done with the second form of <code>GetMVProductMatrix</code>, where instead of a single multivector, you give a list of multivectors. For each multivector a matrix of the form of <img class="formulaInl" alt="${h^k}_j$" src="form_108.png"> is then evaluated and all those matrices are stacked on top of each other.<p>
Another way to enforce uniqueness of a solution is to look for solutions of a multivector equation in a certain subspace of the algebra. This can be done with the <em>Mask</em> parameter. With the mask parameter you can set which algebra dimensions should be used in the generation of the matrix <img class="formulaInl" alt="${h^k}_j$" src="form_108.png"> . This is best explained with an example. Suppose you want to find all those multivectors <img class="formulaInl" alt="$X$" src="form_105.png"> that satisfy the equation <img class="formulaInl" alt="$e_1\cdot X = 0$" src="form_110.png"> in Euclidean space, i.e. the null space of <img class="formulaInl" alt="$e_1$" src="form_8.png"> .<p>
<div class="fragment"><pre class="fragment"><span class="comment">// Define the basis variables for Euclidean space</span>
<a class="code" href="group__grp__GAFunc.html#ga7">DefVarsE3</a>();

<span class="comment">// Define a multivector variable as e1</span>
A = e1;

<span class="comment">// Generate the multivector product matrix of A</span>
<span class="comment">// for the inner product</span>
MA = <a class="code" href="group__grp__Matrix.html#ga13">GetMVProductMatrix</a>(A, <a class="code" href="group__grp__OpIDs.html#ga2">MVOP_INNER</a>);

<span class="comment">// Find the null space of MA with a </span>
<span class="comment">// singular value decomposition</span>
W = <a class="code" href="group__grp__Matrix.html#ga33">SVD</a>(MA);

<span class="comment">// Transform the diagonal matrix of the</span>
<span class="comment">// singular values to a row vector and</span>
<span class="comment">// display it</span>
?Diag = <a class="code" href="group__grp__Matrix.html#ga6">DiagToRow</a>(W(2));
</pre></div><p>
The output generated by this script is the following. <div class="fragment"><pre class="fragment">Diag = (| 0 0 0 0 1 1 1 1|)
</pre></div><p>
Since there are four singular values that are zero, the null space of <code>MA</code> is four-dimensional. The basis multivectors of this null space are first four columns of the matrix <code>W[3]</code> that was returned from the SVD. These column vectors can be transformed back into actual multivectors with the function <code>Matrix2MV</code>. The following piece of code has to be appended to the above code.<p>
<div class="fragment"><pre class="fragment"><span class="comment">// Transform the singular vectors to multivectors</span>
V = <a class="code" href="group__grp__Matrix.html#ga23">Matrix2MV</a>(W(3));

<span class="comment">// Print the first four (singular) multivector which</span>
<span class="comment">// span the basis of the null space of e1 </span>
<span class="comment">// w.r.t. the inner product.</span>
?V(1);
?V(2);
?V(3);
?V(4);

<span class="comment">// Test the caluculation by evaluating the</span>
<span class="comment">// inner product with all singular multivectors.</span>
?A . V;
</pre></div><p>
This produces the following output. <div class="fragment"><pre class="fragment">Constant = -1^e23
Constant = 1
Constant = -1^e3
Constant = 1^e2
Constant = ([], [], [], [], [ -1 ], [ -1^e3 ], [ -1^e23 ], [ -1^e2 ])
</pre></div><p>
This show that the algebraic basis that spans the null space of <img class="formulaInl" alt="$e_1$" src="form_8.png"> w.r.t. the inner product is given by <img class="formulaInl" alt="$\{1,\,e_2,\, e_3,\,e_2\wedge e_3\}$" src="form_111.png"> .<p>
We see that this solution is not unique. But, suppose we were only interested in the <b>bivectors</b> that lie in the null space of <img class="formulaInl" alt="$e_1$" src="form_8.png"> w.r.t. the inner product. This can be evaluated directly by using the mask parameter of <code>GetMVProductMatrix</code>. The length of the mask list passed to this function must be the same as the algebra dimensions. For example, for Euclidean space the mask list must have 8 entries, and for projective space it must have 16 entries. Each entry in a mask list stands for an algebra dimension. If an entry in the mask list is zero, then the respective algebra dimension will be neglected. The non-zero entries of the mask must have entries counting up from 1 to the number of dimensions the solution space has. However, two or more entries in the mask can also have the same integer number. This expresses the fact that these dimensions should have the same scalar factor in the solution space. This is again best explained by using the above example. The following code only evaluates bivector solutions.<p>
<div class="fragment"><pre class="fragment"><span class="comment">// Define the basis variables for Euclidean space</span>
<a class="code" href="group__grp__GAFunc.html#ga7">DefVarsE3</a>();

<span class="comment">// Define a multivector variable as e1</span>
A = e1;

<span class="comment">// Generate a mask for all bivector components</span>
Mask = [0,           <a class="code" href="group__grp__Misc.html#ga2">Scalar</a> 
        0, 0, 0,     Vector 
        1, 2, 3,     Bivector 
        0            Trivector (Pseudoscalar) 
        ];

<span class="comment">// Generate the multivector product matrix of A</span>
<span class="comment">// for the inner product. Apply the mask</span>
<span class="comment">// such that only bivector components are</span>
<span class="comment">// considered.</span>
MA = <a class="code" href="group__grp__Matrix.html#ga13">GetMVProductMatrix</a>(A, <a class="code" href="group__grp__OpIDs.html#ga2">MVOP_INNER</a>, Mask);

<span class="comment">// Find the null space of MA with a </span>
<span class="comment">// singular value decomposition</span>
W = <a class="code" href="group__grp__Matrix.html#ga33">SVD</a>(MA);

<span class="comment">// Transform the diagonal matrix of the</span>
<span class="comment">// singular values to a row vector and</span>
<span class="comment">// display it</span>
?Diag = <a class="code" href="group__grp__Matrix.html#ga6">DiagToRow</a>(W(2));

<span class="comment">// Transform the singular vectors to multivectors.</span>
<span class="comment">// Now you need to specify the mask again, such</span>
<span class="comment">// that the matrix components are mapped to the</span>
<span class="comment">// correct multivector components.</span>
?V = <a class="code" href="group__grp__Matrix.html#ga23">Matrix2MV</a>(W(3), Mask);

<span class="comment">// Print the first(singular) multivector</span>
<span class="comment">// which spans the basis of the bivector </span>
<span class="comment">// null space of e1 w.r.t. the inner product.</span>
?V(1);

<span class="comment">// Test the caluculation by evaluating the</span>
<span class="comment">// inner product with all singular multivectors.</span>
?A . V;
</pre></div><p>
From the singluar value diagonal matrix we see that this time the solution is unique, i.e. there exists only a single bivector the lies in the null space of <img class="formulaInl" alt="$e_1$" src="form_8.png"> w.r.t. the inner product.<p>
If you replace the definition of the mask in the above example by<p>
<div class="fragment"><pre class="fragment"><span class="comment">// Generate a mask for vector components.</span>
<span class="comment">// Enforce that e2 and e3 are regarded as</span>
<span class="comment">// one dimension in the solution space </span>
<span class="comment">// and must have the same scalar factor.</span>
Mask = [0,           <a class="code" href="group__grp__Misc.html#ga2">Scalar</a> 
        1, 2, 2,     Vector (e1, e2, e3) 
        0, 0, 0,     Bivector (e23, e31, e12) 
        0            Trivector (Pseudoscalar) 
        ];
</pre></div><p>
then the solution space is two dimensional, whereby the first dimension refers to <img class="formulaInl" alt="$e_1$" src="form_8.png"> and the second dimension to <img class="formulaInl" alt="$e_2 + e_3$" src="form_112.png"> . (It is no mistake that vector components of the mask are numbered 1, 2, 2.) The output is now as follows.<p>
<div class="fragment"><pre class="fragment">Diag = (| 0 1|)
V = ([ 1^e2 + 1^e3 ], [ -1^e1 ])
Constant = 1^e2 + 1^e3
Constant = ([], [ -1 ])
</pre></div><p>
We see that the solution is again unique.<h2><a class="anchor" name="sec_SolveMV_VersorEqn">
Solving Versor Equations</a></h2>
You can also use the method described above to solve versor equations. To do so, a feature of the function <a class="el" href="group__grp__Matrix.html#ga13">GetMVProductMatrix()</a> is needed, which was introduced with version 1.5 of CLUScript. This feature is again best descibed with an example.<p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__grp__GAFunc.html#ga7">DefVarsE3</a>();  <span class="comment">// Define variables for E3</span>
A = e1;       <span class="comment">// Define multivector A</span>
B = e2;       <span class="comment">// Define multivector B</span>

<span class="comment">// Evaluate the matrix for the product A * B of the</span>
<span class="comment">// components of A summed over index i of the </span>
<span class="comment">// tensor g^k_ij representing the geometric product.</span>
Agp = <a class="code" href="group__grp__Matrix.html#ga13">GetMVProductMatrix</a>(A, MVOP_GP, 1  from left  );
<span class="comment">// Do the same for product B * A with components of A</span>
gpA = <a class="code" href="group__grp__Matrix.html#ga13">GetMVProductMatrix</a>(A, MVOP_GP, 0  from right );

<span class="comment">// Transform multivector B in matrix representation.</span>
<span class="comment">// Bm is a column vector.</span>
Bm = <a class="code" href="group__grp__Matrix.html#ga24">MV2Matrix</a>(B);

C1m = Agp * Bm; <span class="comment">// Evaluate A B</span>
C2m = gpA * Bm; <span class="comment">// Evaluate B A</span>

?C1 = <a class="code" href="group__grp__Matrix.html#ga23">Matrix2MV</a>(C1m); <span class="comment">// Transform C1m back to a multivector</span>
?C2 = <a class="code" href="group__grp__Matrix.html#ga23">Matrix2MV</a>(C2m); <span class="comment">// Transform C2m back to a multivector</span>
</pre></div><p>
In this example the geometric product matrix for <code>A</code> was evaluated twice: assuming that <code>A</code> is multiplied from the left (<code>Agp = GetMVProductMatrix(A, MVOP_GP, 1)</code>) and assuming it is multiplied from the right (<code>gpA = GetMVProductMatrix(A, MVOP_GP, 0)</code>). Therefore, the matrix product of <code>Agp</code> with <code>Bm</code> is equivalent to the geometric product <code>A * B</code>, and the matrix product of <code>gpA</code> with <code>Bm</code> is equivalent to the geometric product <code>B * A</code>.<p>
This feature is necessary to solve a versor equation of the form <img class="formulaInl" alt="$V X \tilde{V} = Y$" src="form_113.png"> , where <img class="formulaInl" alt="$X$" src="form_105.png"> and <img class="formulaInl" alt="$Y$" src="form_114.png"> are known and <img class="formulaInl" alt="$V$" src="form_70.png"> is the unknown. To make <img class="formulaInl" alt="$V$" src="form_70.png"> a proper versor, it has to satisfy the constraint <img class="formulaInl" alt="$V \tilde{V} = 1$" src="form_115.png"> . This constraint can be used to write the versor equation from above in a slightly different way. <p class="formulaDsp">
<img class="formulaDsp" alt="\[ V X \tilde{V} = Y \;\iff\; V X - Y V = 0. \]" src="form_116.png">
<p>
 At first sight, it does not seem to be possible to solve this equation for <img class="formulaInl" alt="$V$" src="form_70.png"> . However, if we transform it into a matrix equation it may be written as <div class="fragment"><pre class="fragment">gpX * Vm - Ygp * Vm = 0
</pre></div> with <div class="fragment"><pre class="fragment">gpX = <a class="code" href="group__grp__Matrix.html#ga13">GetMVProductMatrix</a>(X, MVOP_GP, 0  from right );
Ygp = <a class="code" href="group__grp__Matrix.html#ga13">GetMVProductMatrix</a>(Y, MVOP_GP, 1  from left  );
Vm = <a class="code" href="group__grp__Matrix.html#ga24">MV2Matrix</a>(V);
</pre></div><p>
This means, that we are simply looking for the null space of the matrix <code>(gpX - Ygp)</code>. If we also enforce that the result can only have scalar and bivector components using a mask, then all the constraints we need are enforced  implicitly. That is, the resulting null space has to consist of versors and nothing else. If we use a singular value decomposition (SVD) to find the null space, then the best versor in a least squares sense should be found.<p>
Note that it may be shown that the dimension of the null space of the matrix <code>(gpX - Ygp)</code> is always a power of two. For each constraint data pair <code>(X,Y)</code>, which is taken into account, the power of the dimension of the null space of the matrix is at most reduced by one. The following example will help to clarify this.<p>
<div class="fragment"><pre class="fragment"><span class="comment">// Mask for scalar and bivector components</span>
Mask = [1,
        0, 0, 0,
        2, 3, 4,
        0];

<span class="comment">// Create a rotor which we later want to find again</span>
?R = <a class="code" href="group__grp__GAFunc.html#ga22">RotorE3</a>(0,1,0, <a class="code" href="group__grp__MathConst.html#ga1">Pi</a>/4);

<span class="comment">// Data points</span>
A1 = <a class="code" href="group__grp__GAFunc.html#ga36">VecE3</a>(1,0,0);
<span class="comment">// Rotate A1 with R</span>
?B1 = R * A1 * ~R;

<span class="comment">// Create matrices</span>
gpA1 = <a class="code" href="group__grp__Matrix.html#ga13">GetMVProductMatrix</a>(A1, MVOP_GP, Mask, 0  right );
B1gp = <a class="code" href="group__grp__Matrix.html#ga13">GetMVProductMatrix</a>(B1, MVOP_GP, Mask, 1  left  );

<span class="comment">// The matrix from which we need to find the null space</span>
M = gpA1 - B1gp;

<span class="comment">// Evaluate SVD</span>
L = <a class="code" href="group__grp__Matrix.html#ga33">SVD</a>(M);

<span class="comment">// Diagonal of SVD as row vector</span>
?Diag = <a class="code" href="group__grp__Matrix.html#ga6">DiagToRow</a>(L(2));

<span class="comment">// There are two solutions.</span>
<span class="comment">// Transform the matrix L(3) which contains the</span>
<span class="comment">// singular vectors as columns to multivectors.</span>
MV = <a class="code" href="group__grp__Matrix.html#ga23">Matrix2MV</a>(L(3), Mask);

<span class="comment">// The first two multivectors in list MV are</span>
<span class="comment">// solutions to the equation.</span>
?<span class="stringliteral">""</span>;
?<span class="stringliteral">"Solutions for versor:"</span>;
?V1 = MV(1);
?V2 = MV(2);

<span class="comment">// Check this</span>
?<span class="stringliteral">""</span>;
?<span class="stringliteral">"Check solutions:"</span>;
?Sol1 = V1 * A1 * ~V1;
?Sol2 = V2 * A1 * ~V2;
</pre></div><p>
The output of this code is<p>
<div class="fragment"><pre class="fragment">R = 0.924 + -0.383^e31
B1 = 0.707^e1 + -0.707^e3
Diag = (| 0 0 2 2|)

Solutions <span class="keywordflow">for</span> versor:
V1 = 0.924 + -0.383^e31
V2 = -0.924^e23 + 0.383^e12

Check solutions:
Sol1 = 0.707^e1 + -0.707^e3
Sol2 = 0.707^e1 + -0.707^e3
</pre></div><p>
Even though the solution space was already reduced by the mask, there are still two solutions. This is because a rotation is not properly constrained by just one point pair. Note that instead of points we can also use any other geometric entity which can be represented in geometric algebra. Here is the same script with two point pairs.<p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__grp__GAFunc.html#ga7">DefVarsE3</a>();

<span class="comment">// Mask for scalar and bivector components</span>
Mask = [1,
        0, 0, 0,
        2, 3, 4,
        0];

<span class="comment">// Create a rotor which we later want to find again</span>
?R = <a class="code" href="group__grp__GAFunc.html#ga22">RotorE3</a>(0,1,0, <a class="code" href="group__grp__MathConst.html#ga1">Pi</a>/4);

<span class="comment">// Data points</span>
<span class="comment">// This can also be mixed points, planes in E3.</span>
<span class="comment">// In P3 or N3 any other geometric entities could be used.</span>
A = [<a class="code" href="group__grp__GAFunc.html#ga36">VecE3</a>(1,0,0), <a class="code" href="group__grp__GAFunc.html#ga36">VecE3</a>(0,0,1)];
<span class="comment">// Rotate data points A with R</span>
?B = R * A * ~R;

<span class="comment">// Create matrices</span>
<span class="comment">// Since A and B are now a lists of multivectors,</span>
<span class="comment">// an appropriate matrix which stack the separate</span>
<span class="comment">// matrices for each multivector on top of each other</span>
<span class="comment">// is generated.</span>
gpA = <a class="code" href="group__grp__Matrix.html#ga13">GetMVProductMatrix</a>(A, MVOP_GP, Mask, 0  right );
Bgp = <a class="code" href="group__grp__Matrix.html#ga13">GetMVProductMatrix</a>(B, MVOP_GP, Mask, 1  left  );

<span class="comment">// The matrix from which we need to find the null space</span>
M = gpA - Bgp;

<span class="comment">// Evaluate SVD</span>
L = <a class="code" href="group__grp__Matrix.html#ga33">SVD</a>(M);

<span class="comment">// Diagonal of SVD as row vector</span>
?Diag = <a class="code" href="group__grp__Matrix.html#ga6">DiagToRow</a>(L(2));

<span class="comment">// There is now only one solution.</span>

<span class="comment">// Transform the matrix L(3) which contains the</span>
<span class="comment">// singular vectors as columns to multivectors.</span>
MV = <a class="code" href="group__grp__Matrix.html#ga23">Matrix2MV</a>(L(3), Mask);

<span class="comment">// The first multivector in list MV is the</span>
<span class="comment">// solution to the equation.</span>
?<span class="stringliteral">""</span>;
?<span class="stringliteral">"Solution for versor:"</span>;
?V = MV(1);

<span class="comment">// Check this</span>
?<span class="stringliteral">""</span>;
?<span class="stringliteral">"Check solution:"</span>;
?Sol = V * A * ~V;
</pre></div><p>
The output created is the following,<p>
<div class="fragment"><pre class="fragment">R = 0.924 + -0.383^e31
B = ([ 0.707107^e1 + -0.707107^e3 ], [ 0.707107^e1 + 0.707107^e3 ])
Diag = (| 0 2 2 2.828427|)

Solution <span class="keywordflow">for</span> versor:
V = 0.924 + -0.383^e31

Check solution:
Sol = ([ 0.707107^e1 + -0.707107^e3 ], [ 0.707107^e1 + 0.707107^e3 ])
</pre></div> </body></html>
